# 一、举例说明

## 1.1 Integer 

**享元模式**

Integer有一个缓存，范围为-128~127，Integer i1 = 10，在字节码中实质是调用了Integer.valueOf，在此范围内返回的就是IntergerCache中的Integer对象，否则会返回新的Integer对象

```java
  Integer i1 = 10;
  Integer i2 = 10;
  System.out.println(i1 == i2);//true

    Integer i3 = 128;
    Integer i4 = 128;
    System.out.println(i3 == i4);//false

    Integer x = 5;//调用Integer.valueOf 从数组中返回
    int y = 5; // 基本数据5 
    System.out.println(x == y);//true
```

## 1.2 多态

```java
class Father {
    int x = 10;

    public Father() {
        this.print();
        x = 20;
    }
    public void print() {
        System.out.println("Father.x = " + x);
    }
}

class Son extends Father {
    int x = 30;
    //    float x = 30.1F;
    public Son() {
        this.print();
        x = 40;
    }
    public void print() {
        System.out.println("Son.x = " + x);
    }
}

public class SonTest {
    public static void main(String[] args) {
        Father f = new Son();
        System.out.println(f.x);
    }
}
// 打印：
Son.x = 0
Son.x = 30
20

```

new Father() 子节码

1. 先默认初始化，此时Father.x=0,
2. 在显式初始化/构造器初始化，按位置优先执行，Father.x=10
3. Son此时只执行了默认初始化，此时Son.x=0
4. Father构造器中调用this.print(),但this是Son，因此打印的是Son.x=0
5. print()执行完，Father.x=20
6. Son开始【2】Son.x=30,Son.print()--> Son.x=30
7. 最后Son.x=40
8. **属性没有多态**，此时f.x=20

```java
 0 aload_0
 1 invokespecial #1 <java/lang/Object.<init>>
 4 aload_0
 5 bipush 10
 7 putfield #2 <com/zzc/Father.x>
10 aload_0
11 invokevirtual #3 <com/zzc/Father.print>
14 aload_0
15 bipush 20
17 putfield #2 <com/zzc/Father.x>
20 return
```

# 二、Class文件结构

​	Class的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变

​	Class 文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型:**无符号数和表**。

​	无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8编码构成字符串值。

​	表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class 文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明

```java
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

![img](D:\myself\springboot-example\文档\typora\images\jvm44.png)

## 2.1 Magic Number

每个 Class 文件开头的4个字节的无符号整数称为魔数（Magic Number）

它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即:魔数是Class文件的标识符。

魔数值固定为0xCAFEBABE。不会改变。

如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误:

```
Error: A JNI error has occurred， please check your installation and try again
Exception in thread "main" java.lang.ClassFormatError: Incompatible magic value 1885430635 in classfile StringTest
```

使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。

## 2.2 版本号

u2:minor_version + u2:major_version 

## 2.3 常量池

- 常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析也有着至关重要的作用。
- 常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的无符号数，代表**常量池容量计数值**（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的

### 2.3.1 常量池表

constant_pool是一种表结构，以1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项

常量池主要存放两大类常量:**字面量（Literal） 和符号引用（Symbolic References**）

- 字面量：基本数据类型，字符串类型常量等
- 符号引用：类、字段、方法、接口等的符号引用

它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。

常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte（标记字节、标签字节）

常量池主要存放两大类常量:字面量（Literal） 和符号引用（Symbolic References）

![image-20210403184925782](D:\myself\springboot-example\文档\typora\images\jvm46.png)

补充说明：

​		 虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。**当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用**，并翻详到具体的内存地址中。这里说明下符号引用和直接引用的区别与关联:

- **符号引用**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。
- **直接引用**：直接引用可以是直接**指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的**，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

### 2.3.2 常量池类型

![img](D:\myself\springboot-example\文档\typora\images\jvm47.png)

![img](D:\myself\springboot-example\文档\typora\images\jvm48.png)

### 2.3.3 小结

​	常量池:可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一

​	常量池中为什么要包含这些内容？

​	Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解

## 2.4 访问标识 access flag

​	该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口；是否定义为 public类型；是否定义为 abstract类型；如果是类的话，是否被声明为 final等。各种访问标记如下所示:

| 标志名称       | 标志值 | 含义                       |
| -------------- | ------ | -------------------------- |
| ACC_PUBLIC     | 0x0001 | public类型                 |
| ACC_FINAL      | 0x0010 | final，只有类可以设置      |
| ACC_SUPER      | 0x0020 | 使用增强的方法调用父类方法 |
| ACC_INTERFACE  | 0x0200 | 接口                       |
| ACC_ABSTRACT   | 0x0400 | abstract                   |
| ACC_SYNTHETIC  | 0x1000 | 标志此类并非由用户代码产生 |
| ACC_ANNOTATION | 0x2000 | 注解                       |
| ACC_ENUM       | 0x4000 | 枚举                       |

- **Demo.class 中，这个值为21，是ACC_PUBLIC（1）和 ACC_SUPER（20）相加的和**

## 2.5 类索引、父类索引、接口索引

![image-20210403194224864](D:\myself\springboot-example\文档\typora\images\jvm49.png)

- interfaces []中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count
- interfaces[i]必须为CONSTANT_Class_info结构

## 2.6 字段表集合

- 用于描述接口或类中声明的变量。字段（field）包括类变量以及实例变量，但是不包括方法内部、代码块内部声明的局部变量。
- 字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

 fields_count （字段计数器）

 fields[]（字段表）

### 2.6.1 字段访问标识

![image-20210403200203311](D:\myself\springboot-example\文档\typora\images\jvm50.png)	

### 2.6.2 字段名索引

根据字段名索引的值，查询常量池中的指定索引项即可

### 2.6.3 描述符索引

字段的数据类型

### 2.6.4 属性表集合

个数+集合

```java
ConstantValue_attribute{
    u2 attribute_name_index;  // 类型
    u4 attribute_length;      // 恒为2
    u2 constantvalue_index;   // 常量池中值得位置
}
```

## 2.7 方法表集合

​	methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如:类（接口）初始化方法《clinit》（）和实例初始化方法《init》（）

 methods_count (方法计数器)

 methods[] (方法表)

![image-20210403202056500](D:\myself\springboot-example\文档\typora\images\jvm51.png)

## 2.8 属性表集合

​	方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该class 文件的源文件的名称。以及任何带有RetentionPolicy.CLASS或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解

​	此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息

​	属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。

attributes_ count(属性计数器)

attributes []（属性表）

### 2.8.2 属性类型

| **属性名称**                          | **使用位置**       | **含义**                                                     |
| ------------------------------------- | ------------------ | ------------------------------------------------------------ |
| Code                                  | 方法表             | Java代码编译成的字节码指令                                   |
| ConstantValue                         | 字段表             | final关键字定义的常量池                                      |
| Deprecated                            | 类、方法、字段表   | 被声明为deprecated的方法和字段                               |
| Exceptions                            | 方法表             | 方法抛出的异常                                               |
| EnclosingMethod                       | 类文件             | 仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法 |
| InnerClass                            | 类文件             | 内部类列表                                                   |
| LineNumberTable                       | Code属性           | Java源码的行号与字节码指令的对应关系                         |
| LocalVariableTable                    | Code属性           | 方法的局部变量描述                                           |
| StackMapTable                         | Code属性           | JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配 |
| Signature                             | 类，方法表，字段表 | 用于支持泛型情况下的方法签名                                 |
| SourceFile                            | 类文件             | 记录源文件名称                                               |
| SourceDebugExtension                  | 类文件             | 用于存储额外的调试信息                                       |
| Syothetic                             | 类，方法表，字段表 | 标志方法或字段为编泽器自动生成的                             |
| LocalVariableTypeTable                | 类                 | 使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 |
| RuntimeVisibleAnnotations             | 类，方法表，字段表 | 为动态注解提供支持                                           |
| RuntimelnvisibleAnnotations           | 类，方法表，字段表 | 用于指明哪些注解是运行时不可见的                             |
| RuntimeVisibleParameterAnnotation     | 方法表             | 作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法 |
| RuntirmelnvisibleParameterAnniotation | 方法表             | 作用与  RuntimelnvisibleAnnotations属性类似，作用对象哪个为方法参数 |
| AnnotationDefauit                     | 方法表             | 用于记录注解类元素的默认值                                   |
| BootstrapMethods                      | 类文件             | 用于保存invokeddynanic指令引用的引导方式限定符               |

### 2.8.3 **ConstantValue属性**

ConstantValue属性表示一个常量字段的值。位于 field_info结构的属性表中。

```java
ConstantValue_attribute {
    u2 attribute_name_index；
    u4 attribute_length；
    u2 constantvalue_index；
    //字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。
    //（例如，值是long型的，在常量池中便是CONSTANT_Long）
}
```

### 2.8.4 **Deprecated 属性**

Deprecated属性是在JDK1.1为了支持注释中的关键词@deprecated而引入的。

```
 Deprecated_ attribute{
    u2 attribute_name_ index; 
    u4 attribute_length;
}
```

### 2.8.5 Code属性 

Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了。

| 类型           | 名称                   | 数量             | 含义                     |
| -------------- | ---------------------- | ---------------- | ------------------------ |
| u2             | attribute_name_index   | 1                | 属性名索引               |
| u4             | attribute_length       | 1                | 属性长度                 |
| u2             | max_stack              | 1                | 操作数栈深度的最大值     |
| u2             | max_locals             | 1                | 局部变量表所需的存续空间 |
| u4             | code_length            | 1                | 字节码指令的长度         |
| u1             | code                   | code_length      | 存储字节码指令           |
| u2             | exception_table_length | 1                | 异常表长度               |
| exception_info | exception_table        | exception_length | 异常表                   |
| u2             | attributes_count       | 1                | 属性集合计数器           |
| attribute_info | attributes             | attributes_count | 属性集合                 |

### 2.8.6 **InnerClasses属性**

​	为了方便说明特别定义一个表示类或接口的 Class 格式为C。如果C的常量池中包含某个CONSTANT_Class_info成员，且这个成员所表示的类或接口不属于任何一个包，那么C的ClassFile结构的属性表中就必须含有对应的 InnerClasses属性。InnerClasses属性是在JDK 1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile结构的属性表

### 2.8.7 **LineNumber Table 属性**

LineNumberTable属性是可选变长属性，位于 Code结构的属性表。

LineNumberTable属性是用来描述Java源码行号与字节码行号之间的对应关系。这个属性可以用来在调试的时候定位代码执行的行数。

- start_pc，即字节码行号；line_number，即Java源代码行号。

在 Code属性的属性表中，LineNumberTable属性可以按照任意顺序出现，此外，多个 LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable属性不需要与源文件的行一一对应。

```
LineNumberTable_attribute {
    u2 attribute_name_index:
    u4 attribute_length:
    u2 line_number_table_length;
    {u2 start_pc:
        u2 line_number:
    } line_number_table[line_number_table_length]:
```

### 2.8.8 **LocalVariableTable属性**

LocalVariableTable是可选变长属性，位于Code属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。

- 在 Code属性的属性表中，LocalVariableTable属性可以按照任意顺序出现。Code属性中的每个局部变量最多只能有一个LocalVariableTable属性。
  - start pc + length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾10）
  - index就是这个变量在局部变量表中的槽位（槽位可复用）
  - name就是变量名称
  - Descriptor表示局部变量类型描述

```
LocalVariableTable_attribute {
    u2 attribute_name_index:
    u4 attribute_length:
    u2 local_variable_table_length:
    { u2 start_pc:
        u2 length:
        u2 name_index;
        u2 descriptor_index;
        u2 index;
    } local_variable_table[local_variable_table_length]:
```

### 2.8.9 **Signature 属性**

​	Signature 属性是可选的定长属性，位于 ClassFile， field_info 或 method_info结构的属性表中。在 Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。

### 2.8.10 **SourceFile属性**

| 类型                                | 名称                 | 数量             | 含义       |
| ----------------------------------- | -------------------- | ---------------- | ---------- |
| u2                                  | attribute_name_index | 1                | 属性名索引 |
| u4                                  | attribute_length     | 1                | 属性长度   |
| u1                                  | info                 | attribute_length | 属性表     |
| 可以看到，其总长度总是固定的8个字节 |                      |                  |            |

### 2.8.11 **其他属性**

Java虚拟机中预定义的属性有20多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。

## 2.9 总结

以下数字是转换后的10进制


cafebaby    版本号 常量池计数器n        常量池       访问标识    类索引  父类索引  接口个数       接口集合   ----------------------->
   4u               4u             2u                   （n-1）u         2u              2u           2u             2u          2u * 接口个数

字段访问标识  字段名索引    描述符索引    属性表个数n    [属性表集合](###2.6.4 属性表集合)      --------->
    2u                     2u                    2u                      2u             n*(2+4+2)u

方法访问标识  方法名索引   描述符索引   属性表个数 Code集合
    2u                     2u                   2u                 2u

===========================================

常量池中的一个常量的基本结构：

​	常量类型         常量内容
​	  1u             [具体占多少子节](###2.3.2 常量池类型)

![img](D:\myself\springboot-example\文档\typora\images\jvm52.png)



