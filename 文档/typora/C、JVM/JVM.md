```java
javap -v  Test.class // Test的字节码文件 
```

# 概览

## 1. JVM 架构模型

JAVA编译器输入的指令流基本上是一种**基于栈的指令级架构**，另一种架构是基于寄存器的指令集架构

![image-20210328073506628](D:\myself\springboot-example\文档\typora\images\jvm11.png)

## 2. JVM分类

- **SUN Classic VM** 

  第一款商用的JVM，只有解释器，没有JIT编译器

- **Exact VM**

  具有JIT编译器

- **HotSpot VM**

  jdk1.3后，成为默认的虚拟机

  Oracle JDK、OpenJDK的默认虚拟机

  热点代码探测技术：编译器和解释器并行工作

- **BEA的JRockit**

  专注于服务器端，不关系程序的启动响应时间，全部代码都靠即时编译器编译后执行

  被Oracle收购

- **IBM J9**

# 一、JVM体系结构概述

![image-20201030083700650](D:\myself\springboot-example\文档\typora\images\jvm01.png)

# 二. ClassLoader

![image-20210328083622036](D:\myself\springboot-example\文档\typora\images\jvm12.png)

## 2.1 linking过程

- **Verify**

  确保class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载类的正确性

  文件格式验证（开头cofe baby）、元数据验证、字节码验证、符号引用验证

- **Prepare**

  为类变量分配内存并并初始化0值，类变量分配在方法区

  不包含final static常量，final在编译时就分配了，准备阶段会显式初始化

  不会为实例变量分配初始化

- **Resolve**

  将常量池中的符号引用转为直接引用的过程

  解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等

负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构
​    ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 

## 2.2 initialzation

 	初始化阶段就是执行类构造器方法 `<clinit>()` 的过程

​	 该方法无需定义，是javac编译器自动收集类中所有的**类变量**的赋值动作和静态代码块中的语句合并而来

​	构造器方法中的指令按语句在源文件中出现的顺序执行。

**常量在编译时就已经初始化了**

```java
public class Test{
    private final static int age = 20;
    static {
        num = 20
    }
    private static int num = 10;
    public static void main(String[] args){
        System.out.print(num); // 输出10
    }
}
```

​	 构造器是虚拟机视角下的 `<init>`

​	 JVM先执行父类的 `<clinit>` ，在执行子类的

​	 类只会被加载一次，因此虚拟机必须保证类的 `<clinit>` 在多线程下被同步加锁

## 2.3 分类

![image-20201030084107145](D:\myself\springboot-example\文档\typora\images\jvm02.png)

​           java 自带的classLoader：

- **Bootstrap ClassLoader**  

​			启动类加载器，C++实现，加载java.* 下的类

​			并不继承自ClassLoader，没有父类加载器

​			加载扩展类加载器和系统类加载器，并指定为他们的父加载器

- **Extension ClassLoader**  

  扩展类加载器，Java实现，加载javax.* 下的类

- **Application ClassLoader**

  系统类加载器，加载当前应用的classpath的所有类

- **用户自定义**
  - 隔离加载类
  - 修改类加载方法
  - 扩展加载源
  - 防止源码泄漏

```java
// 获取启动类加载器加载类的路径
URL[] urls = sun.misc.Launcher.getBootStrapClassPath.getURLs();
for(URL url : urls){
    sout(url.toExternalForm());
}

// 获取扩展类加载器加载类的路径
String[] extDirs = System.getProperty("java.ext.dirs").split(";");

```

## 2.4 双亲委派

当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。

采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。

优点：

​	避免类的重复加载

​	保护程序安全，防止核心API被随意篡改  

## 2.5  沙箱安全机制

## 2.6 其他

​	JVM必须知道一个类是启动类加载器还是用户类加载器加载的。如果是用户类加载器加载的，那么JVM会将这个**类加载的一个引用作为类型信息的一部分保存在方法区**中。当解析一个类到另一个类的引用时，JVM必须保证这两个类的加载器是相同的

​	![image-20210328100532936](D:\myself\springboot-example\文档\typora\images\jvm13.png)

# 三、运行时数据区

![image-20210328101209010](D:\myself\springboot-example\文档\typora\images\jvm14.png)

## 3.1 Program Counter Register

**PC寄存器**

每个线程都有一个程序计数器，是<strong style="color:red">线程私有</strong>的
就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。

如果执行的是一个Native方法，那这个计数器是空的。

用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。

**唯一一个不会发生内存溢出(OutOfMemory=OOM)的区域**

## 3.2 JVM Stack

栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，**对于栈来说不存在垃圾回收问题**，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。

**先入后出**

### 3.2.1 可能出现的异常

- **StackOverflowError**

  栈大小固定，当线程请求分配的栈容量超过虚拟机允许的最大容量是，抛出该异常

- **OutOfMemoryError**

  栈大小动态扩展。在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程是没有足够的内存去创建栈时，抛出该异常

### 3.2.2 参数

> -Xss 1024k  // 栈大小：默认1024k

### 3.2.3 栈帧

- 本地变量（Local Variables）:输入参数和输出参数以及方法内的变量；
- 操作数栈（Operand Stack）:记录出栈、入栈的操作；
- 动态链接（Dynamic Linking）运行时常量池的方法引用
- 方法的返回地址（Return Address）
- 一些附加信息

>java中叫方法，方法在jvm入栈后叫栈帧，场景不同，叫法不同

每个方法执行的同时都会创建一个栈帧，用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间,与等于1Mb左右。

![image-20201031092451168](D:\myself\springboot-example\文档\typora\images\jvm03.png)

栈内存溢出：Exception in thread "main" java.lang.StackOverflowError

#### 3.2.3.1 局部变量表

![image-20210328140731469](D:\myself\springboot-example\文档\typora\images\jvm15.png)

1. 一个数字数组，主要用于**存储方法参数和方法体内的局部变量**：

- 基本数据类型
- 对象引用
- returnAddress 类型

2. **大小是在编译期间确定下来**，保存在方法的Code属性的maximum_local_variables

3. Slot

   局部变量表最基本的存储单元是slot

   32位占1个Slot，64位占2个Slot

4. **一般方法，局部变量表的第一个值就是this的引用，比static 方法多了一个值**

5. 可以重复使用Slot

   ```java
   // 局部变量表长度：3
   // this、a、b|c，b的作用域有限，执行c=3时复用b的Slot
   public void test(){
       int a=1;
       {
           int b=2
       }
       int c = 3;
   }
   ```

   

2. 局部变量表中的变量是重要的垃圾回收根节点

#### 3.2.3.2 操作数栈

> 在方法执行过程中，根据字节码指令，往栈中写入数据或者提取数据，即入栈push、出栈pop

用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间

操作数栈的深度也是在编译器就确定好的，Code.max_stack

栈中元素占用空间大小：

​		32bit占一个栈单位深度

​		64bit占两个

**如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中。**	

```java
public void test(){
	int i = test1();  // 对应的字节码aload0：获取上一个栈帧返回的结果，并保存在操作数栈中
	int j = 10
}
```

#### 3.2.3.3 动态链接

​	**帧数据区：动态链接+方法返回地址+附加信息**

每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，即

动态链接的作用：

​	**将符号引用转换为调用方法的直接引用**

```java
public void test(){
    // 9:  invokevirtual #7  #7指向Costanst Pool，为方法的直接引用
	int i = test1();  
	int j = 10
}
```

#### 3.2.3.4 方法返回地址

存放调用该方法的PC寄存器的值

```java
public void test1(){
	test2();
	int i = 0;
}

// 执行test2完成后，返回test1中的PC寄存器的值，让test1接着执行下面的代码
public void test2(){
	return;
}
```

方法结束：

​	正常执行完毕

​	出现未处理的异常，非正常退出：不会给调用者返回任何值

#### 3.2.3.5 附加信息



### 3.2.4 栈顶缓存技术Top Of Stack Cashing

基于栈式架构所使用的0地址指令更加紧凑，但指令更多。

由于操作数时存储在内存中的，因此频繁地执行内存读/写必然会影响执行速度

解决：

​	**栈顶缓存技术：将栈顶元素全部缓存在CPU的寄存器中，以降低对内存的读写次数，提升执行引擎的执行效率**

### 3.2.5 方法调用

#### 3.2.5.1 静态链接与动态链接

​	**静态链接**：

​			当一个字节码文件被装载进JVM内部，如果被调用方法在编译器可知，且运行时不变：调用方法的符号引用转换为直接引用的过程。

​		    对应着**前期绑定**

​	**动态链接**

​			被调用的方法在编译器无法确定，只能在程序运行期间将符号引用转为直接引用

​			对应着**晚期绑定**

#### 3.2.5.2   虚方法和非虚方法

​		方法在编译期确定了具体的直接引用，在运行期不变，这就是非虚方法

​		静态方法、私有方法、构造器、final方法、父类方法都是非虚方法，其他方法为虚方法

![image-20210328170145688](D:\myself\springboot-example\文档\typora\images\jvm16.png)

#### 3.2.5.3 方法重写

![image-20210328171410831](D:\myself\springboot-example\文档\typora\images\jvm17.png)

**虚方法表**

​	在面向对象的编程中，会很频繁的使用动态分派，如果每次动态分派时都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。

为了提升性能，JVM采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来查找。

​	每个类都有自己的虚方法表，表中存放中各个方法的实际入口

​	**虚方法表在类的linking过程中被创建并开始初始化**，类的变量初始化准备完成后，JVM会把该类的虚方法表也初始化完毕

## 3.3 本地方法栈

**本地接口**的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 **Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies。**

 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket通信，也可以使用Web Service等等，不多做介绍。

## 3.4 堆

**堆可以处于物理上不连续的内存空间，但在逻辑上连续的。**

堆中线程私有的缓冲区 TLAB （Thread Local Allocation Buffer）

### 3.4.1 参数

-Xms和-Xmx通常设置一样的值，目的是为了能够**在垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，提高性能**

```shell
-Xms 堆的起始内存，等价于 -XX:InitialHeapSize  默认值：电脑内存大小 / 64
-Xmx 堆的最大内存，等价于 -XX:MaxHeapSize      默认值：电脑内存大小 / 4
```

**新生代和老年代比例：**

```shell
-XX:NewRatio=2 默认2，表示新生代:老年代=1:2
-Xmn 新生代的大小

新生代 = Eden + S0 +S1 默认比例：8:1:1
 -XX:SurvivorRatio=8
 但实际上比例并非如此，jvm有个自适应的内存分配策略-XX:-UseAdaptiveSizePolicy,除非显示设置-XX:SurvivorRatio=8，比例才会如我们想的那样
```

**查看参数设置**

```
方式1：
    jps
    jstat -gc 进程PID
方式2：
	-XX:+PrintGCDetails
```

### 3.4.2 对象分配

​    伊甸园区满：将伊甸园区和from区一起触发YGC

​	from区满时，将对象直接放入老年代

![image-20210329190708147](D:\myself\springboot-example\文档\typora\images\jvm18.png)

### 3.4.3 TLAB

避免多个线程操作同一地址，需要使用加锁机制，影响分配速度

![image-20210329201259044](D:\myself\springboot-example\文档\typora\images\jvm20.png)

![image-20210329201339483](D:\myself\springboot-example\文档\typora\images\jvm21.png)

### 3.4.4 逃逸分析

#### 3.4.4.1 栈上分配

**堆是分配对象存储的唯一选择吗？**

​	不是，还可以在栈上分配对象

>**如果经过逃逸分析后，该对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**
>
>通俗来说，就是看一个对象能否在方法外部被使用

```java
// a并没有逃出方法test1，分配在栈上
// b通过getB得到，在其他方法，很有可能改变了b值，所以发生了逃逸，b对象分配在堆上
public void test1(){
    A a = new A();
    B b = getB();
}

B b;
public B getB(){
    return b;
}
```

#### 3.4.4.2 同步省略

> 如果一个对象被发现只能从一个线程被访问，那么对于这个对象的操作可以不考虑同步

```java
public void test(){
    Object o = new Object();
    synchronized(o){
        int i=0;
    }
}

//经过逃逸分析 o变量不会只能被当前线程方法，代码优化：
public void test(){
    Object o = new Object();
    int i = 0;
}
```

#### 3.4.4.3 标量替换

标量Scalar：无法被分解成更小的数据的数据。Java八大原始类型

聚合量Aggregate：可以被分解的数据。Java对象

>标量替换：
>
>​	在JIT阶段，经过逃逸分析，发现一个对象不会被外界访问，讲过JIT优化，会把这个对象拆分成若干个成员变量。
>
> 这位栈上分配提供了基础

```java
public void test(){
    User u = new User;
    u.name = "zzc";
    u.age = 24;
}

// 经过变量替换
public void test(){
    String uName = "zzc";
    int uAge = 24;
}
```

#### 3.4.4.4 总结

![image-20210329211352370](D:\myself\springboot-example\文档\typora\images\jvm22.png)

### 3.4.5 Minor GC、Major GC、Full GC

JVM在进行GC时，并非对整个堆一起回收，大部分是指对新生代的回收

- 部分收集（Partial GC）
  - Minor/Young GC : 新生代的回收
  - Major/Old GC：老年代的回收
    - 目前，只有 CMS GC会有单独收集老年代的行为
  - Mixed GC 混合收集 ： 收集整个新生代以及部分老年代
    - 目前，只有G1 GC会有这种行为

- 整堆收集（Full GC）： 收集整个java堆和方法区的垃圾回收

**Major、Full GC 一般会比Minor GC慢10倍以上**

**触发 Full GC 的条件**

1. System.gc(); 系统建议但不必然执行
2. 老年代空间不足
   - 通过Minor GC 后进入老年代的大小 > 老年代可用内存
   - S0、S1区满，进入老年代的大小 > 老年代可用内存
3. 方法区空间不足	

### 3.4.6 内存分配策略

![image-20210329195139645](D:\myself\springboot-example\文档\typora\images\jvm19.png)

- 优先分配到Eden区

- 大对象直接分配到老年代

- 长期存活的对象分配到老年代

- 动态对象年龄判断

  如果相同年龄的对象所占空间的综合 > Survivor空间的一半，年龄>=该年龄的对象可以直接进入老年代，无需等待年龄阈值

- 空间分配担保

  `-XX:HandlePromotionFailure`

## 3.5 方法区

默认JVM为HotSpot JVM

方法区逻辑上属于堆的一部分，但对于HotSpotJVM而言，方法区还有一个别名：Non-Heap非堆，目的就是要和堆分开

### 3.5.1 基本理解

- 线程共享的内存区域
- 方法区在JVM启动时被创建，物理内存空间可以不连续，关闭JVM释放整个内存
- 大小可以固定也可以动态扩展
- 方法区的大小决定了系统可以保存多少个类信息，方法区逸出：OOM：PermGen space | Metasapce

### 3.5.2 演进过程

jdk 7： 永久代

jdk 8：**元空间，不在虚拟机设置的内存中，直接使用本地内存**

|        | 永久代         | 堆                     | 元空间                     |
| ------ | -------------- | ---------------------- | -------------------------- |
| jdk1.6 | 静态变量       |                        | ----------------           |
| jdk1.7 | 逐步去除永久代 | 字符串常量池、静态变量 | ----------------           |
| jdk1.8 | ----------     | 字符串常量池、静态变量 | 类型信息、字段、方法、常量 |

**永久代为什么会被元空间替换**

	1. 永久代大小很难确定
 	2. 永久代调优困难

**StringTable 为什么要调整**

​	jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存.

**静态变量存放位置**

​	所有的对象都存放在堆上

​	静态变量staticObjcet本身也存放在堆上

​	成员变量instanceObject作为类对象的一部分也存放在堆上

​    局部变量localObject在入栈时存放在局部变量表

```java
public class Test{
    static Object staticObject = new Object();
    Object instanceObject = new Object();
    
    void test(){
        Object localObject = new Object();
    }
}
```



### 3.5.3 参数

jdk7

```java
-XX:PermSize       // 永久代初始大小，默认20.75M
-XX:MaxPermSize    // 最大空间：32位机器默认64M；64位默认82M
```

jdk8

```java
-XX:MetaspaceSize    // windows 默认21M
-XX:MaxMetaspaceSize // windows 默认-1，没有限制
```

注意：**MetasapceSize的设置**

​	初始高水位线：21M。一旦触及这个水位线，Full GC触发并卸载没有的类，然后高水位线被重置。

新的高水位线的值取决于被释放元空间的大小。如果释放的元空间不足，适当提高该值；如果释放过多，则适当降低该值。

​	**如果初始值设置过低，上述调整会多次放生，频繁调用Full GC。因设置一个相对较高的值。**

### 3.5.4 方法区的内部结构

类型信息、常量、静态变量、即时编译器编译后的代码缓存等

#### 3.5.4.1 类型信息

- 类型的完整有效名称：全名=包名.类名
- 直接父类的完整有效名
- 类型修饰符：public abstract final
- 实现的直接接口的有序列表

#### 3.5.4.2 域（Field）信息

​	域名称、类型、修饰符

#### 3.5.4.3 方法（Method）信息

- 方法名称
- 返回类型
- 方法参数数量和类型（按顺序）
- 方法修饰符
- 方法的字节码（bytecodes）、操作数栈、局部变量表及大小
- 异常表

### 3.5.5 常量池与运行时常量池

​	字节码内部包含了常量池，经过加载、链接、初始化后进入内存，JVM读取后将其加入运行时常量池

- 运行时常量池（ Runtime Constant Pool）是方法区的一部分。
- 常量池表（Constant Pool Table）是Class文件的一部分，==用于存放编译期生成的各种字面量与符号引用==，这部分内容将在类加载后存放到方法区的运行时常量池中。
- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。

- 运行时常量池，相对于Class文件常量池的另一重要特征是：==具备动态性==。
  - String.intern()

- 运行时常量池类似于传统编程语言中的符号表（symbol table） ，但是它所包含的数据却比符号表要更加丰富一些。
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。

### 3.5.6 垃圾回收

​	**垃圾收集行为在方法区很少见，主要是针对类型的卸载和常量池的回收**。

​	**方法区内常量池**之中主要存放的两大类常量：字面量和符号引用。

> 只要常量池中的常量没有被任何地方引用，就可以被回收。

​	字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：

- 1、类和接口的全限定名
- 2、字段的名称和描述符
- 3、方法的名称和描述符

  **类型信息的回收**

​	1. 该类所有的**实例**都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。

2. 加载该类的**类加载器**已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。|】

3. 该类对应的java.lang.**Class对象**没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

​    在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力

## 3.6 对象的实例化内存布局

### 3.6.1 对象的实例化方式

1. new

2. Class的newInstance（）：反射的方式，只能调用空参的构造器，权限必须是public

3. Constructor的newInstance（Xxx）：反射的方式，可以调用空参、带参的构造器，权限没有要求

4. 使用clone（） ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）

5. 使用反序列化：从文件中、从网络中获取一个对象的二进制流

6. 第三方库Objenesis

### 3.6.2 对象创建步骤

1. 判断对象对应的类是否加载、链接、初始化

2. 为对象分配内存

   - 如果内存规整一**指针碰撞**（标记-压缩算法）

   - 如果内存不规整：

     虚拟机需要维护一个列表，**空闲列表**（标记-清除算法）分配

   - 具体使用哪个看具体的垃圾回收器

3. 处理并发安全问题
   - 采用CAS配上失败重试保证更新的原子性
   - 每个线程预先分配一块TLAB

4. 初始化分配到的空间一所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用

5. 设置对象的对象头

6. 执行init方法进行初始化

### 3.6.3 对象的内存布局

![img](D:\myself\springboot-example\文档\typora\images\jvm23.png)

内存布局分类：

![image-20210330222310645](D:\myself\springboot-example\文档\typora\images\jvm24.png)

### 3.6.4 对象的访问定位

JVM是如何通过栈帧中的对象引|用访问到其内部的对象实例的呢？

​	定位,通过**栈上reference**访问

对象访问的两种方式：

 1. 句柄访问

    <img src="D:\myself\springboot-example\文档\typora\images\jvm25.png" alt="img" style="zoom:50%;" />

 2. 直接指针访问（HotSpot采用）

    <img src="D:\myself\springboot-example\文档\typora\images\jvm26.png" alt="img" style="zoom:50%;" />

句柄访问和直接指针的比较：

​	专门在堆中开辟空间存储句柄池，占用内存；

​	通过栈上引用找对象需要两步，效率较低

​	但在对象移动后，栈引用地址无需改变，只需要改变句柄池的对象指针

## 3.7 直接内存（Direct Memory）

简单理解： java process memory = java heap + native memory

- 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域
- 直接内存是Java堆外的、直接向系统申请的内存区间
- 通常，访问直接内存的速度会优于Java堆。即读写性能高
  - 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存
  - Java的NIO库允许Java程序使用直接内存，用于数据缓冲区
- 也可能导致OutOfMemoryError异常:OutOfMemoryError: Direct buffer memory
- 由于直接内存在Java堆外，因此它的大小不会直接受限于一Xmx指定的最大 堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存
- 直接内存大小可以通过MaxDirectMemorySize设置, 如果不指定，默认与堆的最大值一Xmx参数值一致
- ==缺点==
  - 分配回收成本较高
  - 不受JVM内存回收管理

# 四、本地方法接口（Native Interface）

一个Native Method就是一个Java调用非java代码的接口

现状

​	目前该方法的使用越来越少，除非是与硬件有关的应用。

​	Socket通信、RestFul接口

# 五、执行引擎（Execution Engine）

**执行引擎负责解释命令，提交操作系统执行。** 

## 5.1 解释器（ Interpreter）

当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

JVM设计者们的初衷仅仅只是单纯地为了==**满足Java程序实现跨平台特性**==，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。 

 ## 5.2 **JIT （Just In Time Compiler）编译器（即时编译器）**

 就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。

HotSpot VM是目前市面上高性能虛拟机的代表作之一。它采用==解释器与即时编译器并存的架构==。在Java虛拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。

### 5.2.1 热点代码

​	是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码” ，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。

- 一个被多次调用的方法
- 一个方法体内部循环次数较多的循环体

### 5.2.2 探测方式

**方法调用计数器**

- 这个计数器就用于统计方法被调用的次数，它的默认阈值在Client 模式 下是1500 次，在Server 模式下是10000 次。超过这个阈值，就会触发JIT编译。
- -XX ：CompileThreshold
- 热度衰减
  - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度， 如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay） ，而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。
  - 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数
  - -XX： CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。

**回边计数器**

​	统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边” （Back Edge）

<img src="D:\myself\springboot-example\文档\typora\images\jvm27.png" alt="img" style="zoom:50%;" />

## 5.3 设置程序执行方式

- -Xint： 完全采用解释器模式执行程序；
- -Xcomp： 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。
- -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。**（默认）**

# 六、String

## 6.1 基本特性

- String声明为final的， 不可被继承
- String实现了Serializable接口：表示字符串是支持序列化的。 实现了Comparable接口：表示String可以比较大小
- String在jdk8及以前内部定义了final char[],value用于存储字符串数据。jdk9时改为byte[]

- String：代表不可变的字符序列。简称：不可变性
- 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。

## 6.2 String Pool

- String的String Pool 是一个固定大小的Hashtable，默认值大小长度是1009。如果放进StringPool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String. intern时性能会大幅下降。
- 使用`-XX:StringTableSize`可设置StringTable的长度
  - 在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设 置没有要求
  - 在jdk7中，StringTable的长度默认值是60013
  - jdk8开始,1009是StringTable长度可设置的最小值

## 6.3 字符串拼接操作

1.  常量与常量的拼接结果在常量池，原理是编译期优化
2.  只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder
3. 如果拼接的结果调用intern（）方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址

```java
String s1 = "ab";
String s2 = "a" + "b";
s1 == s2 
```

  解析String s1 = "ab";
	String s2 = s1 + "c";
   有字节码可知：变量字符串拼接时，先new StringBuilder对象，在操作append，最终toString生成String对象

**append效率要比字符串拼接高很多**

​	字符串每次拼接都需要new StringBulder对象，在toString返回String对象，而append只会产生一个StringBuilder对象，一个String对象

## 6.4 intern()



# 七、垃圾回收

垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

<strong style="color:red">垃圾回收期间会触发STW（Stop The World），挂起用户线程</strong>

## 7.1 参数

```java
-XX:+PrintFlagsInitial  // 查看所有参数的默认初始值
-XX:+PrintFlagsFinal    // 查看所有参数的最终值
-Xms                    // 初始堆内存 默认物理内存/64
-Xmx                    // 最大堆内存 默认物理内存/4
-Xmn                    // 新生代大小
-XX:NewRatio            // 新生代和老年代的比例
-XX:SurvivorRatio       // Eden和S0/S1的比例
-XX:MaxTenuringThresold // 新生代垃圾的最大年龄
-XX:PrintGCDetails      // 输出详细的GC日志
-XX:HandlePromotionFailure // 是否设置空间分配担保
-XX:+DoEscapeAnalysis   //启用逃逸分析，默认开启
-XX:+EliminateAllocations  // 启用标量替换，默认开启
    
-XX:+HeapDumpOnOutOfMemoryError   // 内存溢出时Dump出当前的内存堆转储快照
-XX:MaxTenuringThreshold   // 对象从幸存者区晋升到老年代的年龄阈值
```

**HandlePromotionFailure**

> 当在新生代无法分配内存的时候，把新生代的对象转移到老生代，然后把新对象放入腾空的新生代。

​	jdk7以及之后：**只要老年代的连续内存空间 > 新生代对象总大小|历次晋升的平均大小：Minor GC，否则Full GC** (具体垃圾收集器具体分析)

## 7.2 垃圾回收算法

### 7.2.1 引用计数法 --标记阶段

引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型 的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

缺点：

- ➢它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
- ➢每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
- ➢引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一 条致命缺陷，导致==在Java的垃圾回收器中没有使用这类算法==。

Python 如何解决循环引用？

- ➢手动解除： 很好理解，就是在合适的时机，解除引用关系。
- ➢使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用

### 7.2.2 根搜索算法 --标记阶段

​	相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高 效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生

> 可达性分析算法是以根对象集合(GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达

**GC Root**

- 虚拟机栈中引用的对象
- 本地方法栈内JNI（通常说的本地方法）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁synchroni zed持有的对象
- Java虚拟机内部的引用。
  - ➢基本数据类型对应的Class对象，一些常驻的异常对象（如： NullPointerException、OutOfMemoryError） ，系统类加载器。

- 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针 对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一.并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root

​	**如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在 一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。**

**这点也是导致GC进行时必须“StopTheWorld"的一个重要原因。**

​	即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的

### 7.2.3 标记清除法 --清除阶段

​	当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存.

	>执行过程：
	>
	>- 标记： Collector从引用根节点开始遍历，标记所有被引用的对象。==一般是在对象的Header中记录为可达对象==。
	>
	>- 清除： Collector对堆 内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。
	>
	>  这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲 的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放

**缺点**

- ➢效率不算高
- ➢在进行Gc的时候，需要停止整个应用程序，导致用户体验差
- ➢这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个**空闲列表**

### 7.2.4 复制算法 -- 清除阶段

​	为了解决标记一清除算法在垃圾收集效率方面的缺陷

> ​	将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收

**优点**：

- 没有标记和清除过程，实现简单，运行高效 **? 复制算法不需要标记，那怎么确定对象是否能够被回收**
- 复制过去以后保证空间的连续性，不会出现“碎片”问题。

**缺点：**

- 此算法的缺点也是很明显的，就是需要两倍的内存空间。
- 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。
   **特别的** 如果系统中的垃圾对象很多，复制算法不会很理想,复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。

**应用场景：**

​	在新生代，对常规应用的垃圾回收，一次通常可以回收708一 99的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。

### 7.2.5 标记-压缩算法 -- 清除阶段

​	复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。

​	标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。

>- 第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象.
>- 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。
>- 之后，清理边界外所有的空间。

​	标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销

### 7.2.6 对比

- 效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。
- 而为了尽量兼顾上面提到的三个指标，标记一整理算法相对来说更平滑一些，但是效率.上不尽如人意，它比复制算法多了一个标记的阶段，比标记一清除多了一个整理内存的阶段。

|          | **Mark-Sweep**   | **Mark-Compact** | Copying                             |
| -------- | ---------------- | ---------------- | ----------------------------------- |
| 速度     | 中等             | 最慢             | 最快                                |
| 空间开销 | 少(但会堆积碎片) | 少(不堆积碎片)   | 通常需要活对象的2倍大小(不堆积碎片) |
| 移动对象 | 否               | 是               | 是                                  |

### 7.2.7 分代收集算法

分代收集算法，是基于这样一个事实：**不同的对象的生命周期是不一样的**。

不同生命周期的对象可以采取不同的收集方式，以便提高回收效率

- 年轻代（Young Gen）
  - 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
  - 这种情况==**复制算法**==的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。·
- 老年代（Tenured Gen）
  - 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
  - 这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由**标记一清除**或者是**标记一清除与标记一整理**的混合实现。
    - ➢Mark阶段的开销与存活对象的数量成正比。
    - ➢Sweep阶段的开销与所管理区域的大小成正相关。
    - ➢Compact阶 段的开销与存活对象的数据成正比。

### 7.2.8 增量收集算法

​	上述现有的算法，在垃圾回收过程中，应用软件将处于一种**stop the World**的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。

>基本思想
>
> 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让**垃圾收集线程和应用程序线程交替执行**。
>每次，**垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成**

​	总的来说，增量收集算法的基础仍是传统的标记一清除和复制算法。增量收集算法**通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作**。

​	**缺点**：

​	使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

### 7.2.9 分区算法

​	一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。

​	为了更好地控制GC产生的停顿时间，将一块 大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

​	**分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。**

​	每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间

<img src="D:\myself\springboot-example\文档\typora\images\jvm28.png" alt="16" style="zoom:50%;" />

## 7.3 对象的finalization机制

当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize（）方法

finalize（）方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。

应该交给垃圾回收机制调用。理由包括下面三点：**永远不要主动调用某个对象的finalize （）方法**

- ➢在finalize（） 时可能会导致对象复活。
- ➢finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（） 方法将没有执行机会。
- ➢一个糟糕的finalize （）会严重影响GC的性能。

**对象回收步骤：**

​	如果对象objA到GC Roots没有引用链，则进行第一 次标记。

​	进行筛选，判断此对象是否有必要执行finalize（）方法

1. ①如果对 象objA没有重写finalize（）方法，或者finalize （）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
2. ②如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F一Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。
3. ③finalize（）方法是对象逃脱死亡的最后机会，稍后Gc会对F一Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。

## 7.4 指针碰撞

​	如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer） 。

​	**优点**

- 消除了标记一清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只 需要持有一个内存的起始地址即可。
- 消除了复制算法当中，内存减半的高额代价。

​    **缺点**

- 从效率.上来说，标记一整理算法要低于复制算法。
- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。· 移动过程中，需要全程暂停用户应用程序。即： STW

## 7.5 System.gc

​	在默认情况下，通过System.gc （）或者Runtime . getRuntime（） .gc（）的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存

​	然而System.gc（）调用附带一个免责声明，==无法保证对垃圾收集器的调用(**无法保证马上触发GC**)

```java
public class LocalVarGC {
    // buffer不会回收
    public void localvarGC1() {
        byte[] buffer = new byte[10 * 1024 * 1024];//10MB
        System.gc();
    }

    // buffer 会回收
    public void localvarGC2() {
        byte[] buffer = new byte[10 * 1024 * 1024];
        buffer = null;
        System.gc();
    }

    // buffer 不会被回收
    // 在栈的局部变量表中，buffer仍然占据了一个slot
    public void localvarGC3() {
        {
            byte[] buffer = new byte[10 * 1024 * 1024];
        }
        System.gc();
    }

    // buffer被回收
    // 在栈的局部变量表中，buffer占据一个slot，在value执行后，buffer已经出了作用域，value会复用该slot，所以buffer被回收
    public void localvarGC4() {
        {
            byte[] buffer = new byte[10 * 1024 * 1024];
        }
        int value = 10;
        System.gc();
    }
    
	// buffer被回收
    public void localvarGC5() {
        localvarGC1();
        System.gc();  
    }

    public static void main(String[] args) {
        LocalVarGC local = new LocalVarGC();
        local.localvarGC5();
    }
}
```

## 7.6 内存溢出与内存泄漏

**内存溢出OutOfMemoryError**

​	**没有空闲内存，并且垃圾收集器也无法提供更多内存**

​	（1） Java虚拟机的堆内存设置不够

​	（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）

​	在抛出0utOfMemoryError之 前，通常垃圾收集器会被触发，尽其所能去清理出空间。

**内存泄漏Memory Leak**

> 只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏

- 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致0OM，也可以叫做宽泛意义上的“内存泄漏

**举例：**

​	1、单例模式
 单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。

​	2、一些提供close的资源未关闭导致内存泄漏 数据库连接（ dataSourse. getConnection（）），网络连接（socket）和io连接必须手动close，否则是不能被回收的。

## 7.7 垃圾回收器的并发与并行

**并行（Parallel）** ：**指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态**。

- 如ParNew、 Parallel Scavenge、 Parallel 0ld；

<img src="D:\myself\springboot-example\文档\typora\images\jvm29.png" alt="4" style="zoom: 67%;" />

**并发（Concurrent） ：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。**

- ➢用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；
- ➢如： CMS、G1

​	<img src="D:\myself\springboot-example\文档\typora\images\jvm30.png" alt="5" style="zoom:50%;" />

## 7.8 安全点与安全区域

### 7.8.1 安全点(Safepoint)

- 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint） ”
- Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。

**如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？**

- 抢先式中断： （目前没有虚拟机采用了） 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。
- 主动式中断： 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。

### 7.8.2 安全区域(Safe Region)

  Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。
  安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region 看做是被扩展了的Safepoint。

**实际执行时:**

- 1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会 忽略标识为Safe Region状态 的线程；
- 2、当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；

## 7.9 引用

我们希望能描述这样一类对象： 当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。

### 7.9.1 强引用--不回收

​	最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“0bject obj=new object（ ）”这种引用关系。==无论任何情况下，只要强引用关系还存在，垃圾收集器就**永远不会回收**掉被引用的对象

### 7.9.2 软引用--内存不足即回收

> ​	软引用是用来描述一 些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常

​	软引用通常用来实现内存敏感的缓存

```java
Object obj = new object（）； //声明强引用
SoftReference<0bject> sf = new SoftReference<0bject>（obj）；
obj = null； //销毁强引用
```

### 7.9.3 弱引用--发现即回收

​	弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象

​	但是，由于垃圾回收器的线程通常优先级很低，因此，并不一 定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间

```java
Object obj = new object（）； //声明强引用
WeakReference<0bject> sf = new WeakReference<0bject>（obj）；
obj = null； //销毁强引用
    
通过查看WeakHashMap源码,可以看到其内部类Entry使用的就是弱引用
line 702 -> private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {...}
```

### 7.9.4 虚引用--对象回收跟踪

​	一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收

​	它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null

​	**为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程**。比如：能在这个对象被收集器回收时收到一个系统通知。

​	虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况

​	由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录

```java
object obj = new object();
ReferenceQueuephantomQueue = new ReferenceQueue( ) ;
PhantomReference<object> pf = new PhantomReference<object>(obj, phantomQueue); 
obj = null;
```

解释**【当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况】**

```
public class PhantomReferenceTest {
    public static PhantomReferenceTest obj;//当前类对象的声明
    static ReferenceQueue<PhantomReferenceTest> phantomQueue = null;//引用队列

    public static class CheckRefQueue extends Thread {
        @Override
        public void run() {
            while (true) {
                if (phantomQueue != null) {
                    PhantomReference<PhantomReferenceTest> objt = null;
                    try {
                        objt = (PhantomReference<PhantomReferenceTest>) phantomQueue.remove();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (objt != null) {
                        System.out.println("追踪垃圾回收过程：PhantomReferenceTest实例被GC了");
                    }
                }
            }
        }
    }

    @Override
    protected void finalize() throws Throwable { //finalize()方法只能被调用一次！
        super.finalize();
        System.out.println("调用当前类的finalize()方法");
        obj = this;
    }

    public static void main(String[] args) {
        Thread t = new CheckRefQueue();
        t.setDaemon(true);//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。
        t.start();

        phantomQueue = new ReferenceQueue<PhantomReferenceTest>();
        obj = new PhantomReferenceTest();
        //构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列
        PhantomReference<PhantomReferenceTest> phantomRef = new PhantomReference<PhantomReferenceTest>(obj, phantomQueue);

        try {
            //不可获取虚引用中的对象
            System.out.println(phantomRef.get());

            //将强引用去除
            obj = null;
            //第一次进行GC,由于对象可复活，GC无法回收该对象
            System.gc();
            Thread.sleep(1000);
            if (obj == null) {
                System.out.println("obj 是 null");
            } else {
                System.out.println("obj 可用");
            }
            System.out.println("第 2 次 gc");
            obj = null;
            System.gc(); //一旦将obj对象回收，就会将此虚引用存放到引用队列中。
            Thread.sleep(1000);
            if (obj == null) {
                System.out.println("obj 是 null");
            } else {
                System.out.println("obj 可用");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

### 7.9.5 终结器引用FinalReference--了解

它用以实现对象的finalize（）方法，也可以称为终结器引用。

无需手动编码， 其内部配合引用队列使用。

在GC时， 终结器引用入队。由Finali zer线程通过终结器引用找到被引用对象并调用它的finalize（）方法，第二次GC时才能回收被引用对象。

# 八、垃圾回收器

## 8.1 GC分类和性能指标

**线程数分**

​	**串行垃圾回收器和并行垃圾回收器**

​	<img src="D:\myself\springboot-example\文档\typora\images\jvm31.png" alt="1" style="zoom:50%;" />

**按照工作模式分**

- **并发式垃圾回收器**与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。
- **独占式垃圾回收器**（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束

<img src="D:\myself\springboot-example\文档\typora\images\jvm32.png" alt="2" style="zoom:50%;" />

**按碎片处理方式分**

- **压缩式垃圾回收器**会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片 **指针碰撞**
- **非压缩式**的垃圾回收器不进行这步操作。 **空闲列表**

**按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器**

## 8.2 GC性能指标

- **<strong style="color:red">吞吐量</strong>**

​	运行用户代码的时间占总运行时间的比例（总运行时间：程序的运行时间十内存回收的时间）

- **垃圾收集开销**：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。

- <strong style="color:red">暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间

- **收集频率**：相对于应用程序的执行，收集操作发生的频率。

- <strong style="color:red">内存占用</strong>： Java堆区所占的内存大小

- **快速**：一个对象从诞生到被回收所经历的时间。

  标红的这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。

​       这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用 多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。

简单来说，主要抓住两点：

- 吞吐量
- 暂停时间

<img src="D:\myself\springboot-example\文档\typora\images\jvm33.png" alt="3" style="zoom:67%;" />

​	高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快

​	低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一一个交互式应用程序

## 8.3 经典的垃圾回收器

<img src="D:\myself\springboot-example\文档\typora\images\jvm34.png" alt="6" style="zoom:67%;" />



1. 两个收集器间有连线，表明它们可以搭配使用： 

   ​		Serial-------Serial 0ld、

   ​		Serial-------CMS、                                             jdk8废弃、jdk9移除

   ​		ParNew-----Serial 0ld、                                   jdk8废弃、jdk9移除

   ​		ParNew------CMS、                                          jdk14 CMS删除

   ​        Parallel Scavenge---------Serial 0ld、             jdk14废弃

   ​        Parallel Scavenge--------Parallel 0ld、

   ​        G1；

2. 其中Serial 0ld作为CMS 出现"Concurrent Mode Failure"失败的后备预案
3. （<strong style="color:red">红色虚线</strong >）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial 01d这两个组合声明为废弃（JEP 173） ，并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除
4. （<strong style="color:green">绿色虚线</strong>）JDK 14中：弃用Parallel Scavenge和Serial0ld GC组合（JEP366 ）
5. （<strong style="color:cyan">青色虚线</strong>）JDK 14中：删除CMS垃圾回收器 （JEP 363）

## 8.4 **查看默认的垃圾收集器**

- -xx：+PrintCommandLineFlags

- 使用命令行指令： jinfo 一flag   相关垃圾回收器  参数进程ID

## 8.5 Serial回收器：串行回收

​	新生代：复制算法

​	老年代：标记整理算法

​	串行回收、Stop The World

![9](D:\myself\springboot-example\文档\typora\images\jvm35.png)

**优势**

​	简单而高效（与其他收集器的单线程比），对于限定**单个CPU的**环境来说，Seria1收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

- ➢运行在Client模式下的虛拟机是个不错的选择。

  在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB）， 可以在较短时间内完成垃圾收集（几十ms至一百多ms） ，只要不频繁发生，使用串行回收器是可以接受的。

在HotSpot虛拟机中，使用`-XX:+UseSerialGC `参数可以指定年轻代和老年代都使用串行收集器。

**总结**

- 这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。
- 对于交互较强的应用而言，这种垃圾收集器是不能接受的。T一般在Javaweb应用程序中是不会采用串行垃圾收集器的。

## 8.6 ParNew 并行回收

​	年轻代：复制算法；
​    老年代：标记-整理法

​	并行回收、Stop The World

<img src="D:\myself\springboot-example\文档\typora\images\jvm36.png" alt="10" style="zoom:80%;" />

- 对于新生代，回收次数频繁，使用并行方式高效。
- 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行 需要切换线程，串行可以省去切换线程的资源）

**配置**

```java
-XX:+UseParNewGC
-XX:ParallelGCThreads  //限制线程数量，默认开启和CPU数据相同的线程数
```

## 8.7 Parallel Scavenge回收器 吞吐量优先

![11](D:\myself\springboot-example\文档\typora\images\jvm37.png)

​	Parallel Scavenge收集 器的目标则是**达到一个可控制的吞吐量**（Throughput），它也被称为吞吐量优先的垃圾收集器

​	自适应调节策略也是Parallel Scavenge 与ParNew一个重要区别

 	高吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务|，**主要适合在后台运算而不需要太多交互的任务**。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序

​	**Parallel 0ld收集器采用了标记一压缩算法**，但同样也是基于并行回收和”Stop一the一World"机制

​    **jdk8 默认是Parallel Scavenge --- Parallel Old**

```java
//默认开启一个，另一个也会被开启。 （互相激活）
-XX:+UseParallelGC
-XX:+UseParallel0ldGc

//设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。
//  当CPU数量小于8个，值等于CPU数量。
//  当CPU数量大于8个，值等于3+[5*CPU_ Count]/8]
-XX:ParallelGCThreads

// 两者相反 暂停时间越长，Radio参数就容易超过设定的比例
-XX:MaxGCPau3eMillis  //设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒
-XX:GCTimeRatio       //垃圾收集时间占总时间的比例（= 1 / （N + 1））用于衡量吞吐量的大小

//在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
//    在手动调优比较困难的场合，可以直接使用这种自适应的方式，
//    仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。
-XX:+UseAdaptiveSizePolicy设 置Parallel Scavenge收 集器具有自适应调节策略
```

## 8.8 CMS回收器 低延迟

​	在JDK1.5时期， HotSpot推出了一款在强交互应用中几乎可认为有划 时代意义的垃圾收集器： CMS （Concurrent 一Mark 一 Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它**第一次实现了让垃圾收集线程与用户线程同时工作**

​	**CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时 间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验**

​	jdk9的默认垃圾收集器

​	**采用标记-清除法**

### 8.8.1 CMS收集流程

![12](D:\myself\springboot-example\文档\typora\images\jvm38.png)

1. **初始标记**

   Stop一the一World

   这个阶段的主要任务仅仅只是标记出**GCRoots能直接关联到的对象**。

   由于直接关联对象比较小，所以这里的速度非常快

2. **并发标记**

   从GC Roots的 直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行

3. **重新标记**

   Stop一the一World

   ​	由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。

4. **并发清除**

   此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

-  由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用
- CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当**堆内存使用率达到某一阈值**时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。
- **CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial 0ld收集器来重新进行老年代的垃圾收集**

### 8.8.2 优缺点

**优点**

​	低延时、并发收集

**缺点**

​	1）会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。

​	2） CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。

​	3） CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure" 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将 无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

### 8.8.3 参数

```java
// 手动指定使用CMS收集器执行内存回收任务。
// 开启该参数后会自动将-XX;+UseParNewGc打开
-XX:+UseConcMarkSweepGc 

// 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 
// JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68号时，会执行一 .次CMS 回收。 JDK6 5及以上版本默认值为92号
-XX:CMS1ni tiatingOccupanyFraction

// 用于指定在执行完FullGC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。    
-XX:+UseCMSCompactAtFullCollection
// 设置在执行多少次Full GC后对内存空间进行压缩整理。    
-XX:CMSFullGCsBeforeCompaction
    
// 设置CMS的线程数量。 默认启动的线程数是（ParallelGCThreads+3） /4， 
-XX:ParallelCMSThreads 
```

## 8.9 G1回收期 区域化分代式

**在延迟可控的情况下获得尽可能高的吞吐量**

### 8.9.1 概述

- G1是一个**并行回收器**，它把堆内存分割为很多不相关的**区域（Region）** （物理上 不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等
- **G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集**。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。
- G1 （Garbage一First） 是一款**面向服务端应用的垃圾收集器**，主要针对配备**多核CPU及大容量内存**的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征
- **JDK 9及以后的默认垃圾回收器**

### 8.9.2 优势

1. **并行与并发**

    ➢并行性：G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW

    ➢并发性： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

2. **分代收集**

   - 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden             区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
   - 将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代。
   - 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；

3. **空间整合**

   ➢CMS： “标记一清除”算法、内存碎片、若干次Gc后进行一次碎片整理

   ➢G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的.Region之间是复制算法，但整体上实际可看作是标记一压缩（Mark一Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

4. **可预测的停顿时间模型**（即：软实时soft real一time）

   这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者**明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。**

### 8.9.3 缺点

- 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。

- 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。
- 为了保存Region之间的引用（老年代指向了新生代），需要给每个区域维护一个Remember Set，需要占用额外的内存空间

### 8.9.4 参数

```java
// 手动指定使用G1收集器执行内存回收任务。
-XX:+UseG1GC 
    
//设置每个Region的大小。值是2的幂，
//范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。    
-XX:G1HeapRegionSize 
    
//设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms
-XX:MaxGCPauseMillis 
    
//设置sTw.工作线程数的值。最多设置为8
-XX:ParallelGCThread 
//设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。    
-XX:ConcGCThreads
//设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。    
-XX:Ini tiatingHeapOccupancyPercent 
  
// 设置Region的大小    
-XX:G1HeapRegionSize    
```

### 8.9.5 设置G1和适用场景

G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：

- 第一步：开启G1垃圾收集器
- 第二步：设置堆的最大内存
- 第三步：设置最大的停顿时间

G1中提供了三种垃圾回收模式： YoungGC、 Mixed GC和Full GC， 在不同的条件下被触发。

**适用场景**

- 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不.惊喜）

  最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；

  如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。

- 用来替换掉JDK1.5中的CMS收集器； 在下面的情况时，使用G1可能比CMS好：
   ①超过50%的Java堆被活动数据占用；
   ②对象分配频率或年代提升频率变化很大；
   ③GC停顿时间过长（长于0. 5至1秒）。

### 8.9.6 Region

<img src="D:\myself\springboot-example\文档\typora\images\jvm39.png" alt="16" style="zoom: 67%;" />

整体被控制在1MB到32MB之间，且为2的N次幂

可以通过`-XX:G1HeapRegionSize`设定。**所有的Region大小相同，且在JVM生命周期内不会被改变**。

​	一个region 有可能属于Eden， Survivor 或者0ld/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，0表示属于old内存区域。图中空白的表示未使用的内存空间。

G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H。

设置H的原因：

- 对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待

### 8.9.7 G1垃圾回收过程

<img src="D:\myself\springboot-example\文档\typora\images\jvm40.png" alt="17" style="zoom:50%;" />

#### 8.9.7.1 简单理解

1. 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个**并行的独占式收集器**。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。

2. 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。

3. 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。

#### 8.9.7.2 记忆集和写屏障

> **一个对象被不同区域引用的问题(分代引用问题)**

一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？

在其他的分代收集器，也存在这样的问题（ 而G1更突出）

回收新生代也不得不同时扫描老年代？

这样的话会降低MinorGC的效率；

·解决方法：

- ➢无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：
- ➢每个Region都有 一个对应的Remembered Set；
- ➢每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .
- ➢然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；
- ➢如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；
- ➢<strong style="color:red">**当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set**；**就可以保证不进行全局扫描，也不会有遗漏**</strong>。

#### 8.9.7.3 回收过程详解 了解就行

**1. 年轻代GC**

- JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。
- 年轻代垃圾回收只会回收Eden区和Survivor区。
- YGC时，首先G1停止应用程序的执行**（Stop一The一World**），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。

然后开始如下回收过程：

- **第一阶段，扫描根**。
   根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。

- 第二阶段，更新RSet

  处理dirty card queue（ 见备注）中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用。

  - dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候， G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。 那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。

- **第三阶段，处理RSet**。
   识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。

- **第四阶段，复制对象**。
   此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间。

- **第五阶段，处理引用**。
   处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。

**2. 并发标记过程**

- 初始标记阶段：标记从根节点直接可达的对象。这个阶段是**STW**的，并且会触发一.次年轻代GC。
- 根区域扫描（Root Region Scanning） ： G1 GC扫描Survivor区 直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。
- 并发标记（Concurrent Marking）： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。
- 再次标记（Remark）： 由 于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。
- 独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。
  - ➢这个阶段并不会实际上去做垃圾的收集
- 并发清理阶段：识别并清理完全空闲的区域。

**3. 混合回收**

当越来越多的对象晋升到老年代oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个0ldGC，除了回收整个Young Region，还会回收一部分的0ldRegion。这里需要注意：是一部分老年代， 而不是全部老年代。可以选择哪些0ldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Fu1l GC。

- 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过一XX： G1MixedGCCountTarget设置）被回收。
- 混合回收的回收集（Collection Set） 包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。
- 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，一xX： G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。
- 混合回收并不一定要进行8次。有一个阈值一Xx： G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。

**4. Full GC**

  G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。
  要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。
  导致G1Full GC的原因可能有两个：

- 1.Evacuation的时候没有足够的to一 space来存放晋升的对象；
- 2.并发处理过程完成之前空间耗尽。

#### 8.9.7.4 建议

1. 年轻代大小

   ➢避免使用一Xmn或一XX：NewRatio等相关选项显式设置年轻代大小➢固定年轻代的大小会覆盖暂停时间目标

2. 暂停时间目标不要太过严苛

   G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间

   评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表 示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。

## 8.10 总结

![21](D:\myself\springboot-example\文档\typora\images\jvm41.png)

**怎么选择垃圾回收器**

- Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。
- 怎么选择垃圾收集器？
  - 1.优先调整堆的大小让JVM自适应完成。
  - 2.如果内存小于100M，使用串行收集器
  - 3.如果是单核、单机程序，并且没有停顿时间的要求，串行收集器
  - 4.如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择
  - 5.如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器
  - 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。
- 最后需要明确一一个观点：
  - 1.没有最好的收集器，更没有万能的收集；
  - 2.调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器

## 8.11 GC 日志分析

```java
//输出Gc日志。类似： -verbose:gc
-XX:+PrintGC 
//输出GC的详细日志
-XX:+PrintGCDetails 
//输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCTimeStamps 
//输出GC的时间戳（以日期的形式，如2013一05一04T21 ： 53：59.234+0800 ）
-XX:+PrintGCDateStamps
//在进行GC的前后打印出堆的信息
-XX:+PrintHeapAtGC 
//日志文件的输出路径
-Xloggc:/logs/gc.log
```

![24](D:\myself\springboot-example\文档\typora\images\jvm08.png)



![25](D:\myself\springboot-example\文档\typora\images\jvm09.png)

# 九、常用调优工具

- JDK命令行
- Eclipse：Memory Analyzer Tool
  - Jconsole
- VisualVM
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy

# 十、JVM参数总结

## 10.1 JVM参数选项类型

### 10.1.1 标准参数选项

​	比较稳定，后续版本基本不会变化

​    以 `-` 开头

​    java -help 可以看到所有的标准参数选项

### 10.1.2 -X参数

功能还是比较稳定，但后续版本可能会变更

以 `-X` 开头

java -X 可以看到所有的X选项

### 10.1.3 -XX参数

不稳定

## 10.2  添加JVM参数选项

tomcat war包，l

​	inux系统： tomcat/bin/catalina.sh JAVA_OPTS=""

​    windows:   catalina.bat set "JAVA_OPTS="

## 10.3 常用的JVM参数选项

### 10.3.1 打印设置的XX选项和值

| -XX:+PrintCommandLineFlags | 可以让在程序运行前打印出用户手动设置或者JVM自动设置的XX选项 |
| -------------------------- | ----------------------------------------------------------- |
| -XX:+PrintFlagslnitial     | 表示打印出所有XX选项的默认值                                |
| -Xx:+PrintFlagsi           | 表示打印出XX选项在运行程序时生效的值                        |
| _XX:+PrintVMOptions        | 打印JVM的参数                                               |

### 10.3.2 堆、栈、方法区等内存大小设置

```shell
# 栈
-Xss128k   设置每个线程的栈大小为128k 等价于-XX:ThreadStackSize=128k
-Xms3550m  等价于-XX:InitialHeapSize，设置JVM初始堆内存为3550M
-Xmx3550m  等价于_XX:MaxHeapSize，设置JVM最大堆内存为3550M

# 堆内存
-Xmn2g                设置年轻代大小为2G，官方推荐配置为整个堆大小的3/8
-XX:NewSize=1024m     设置年轻代初始值为1024M
-XX-MaxNewSize=1024m  设置年轻代最大值为1024M
-XX:SurvivorRatio=8   设置年轻代中Eden区与一个Survivor区的比值，默认为8
-XX:NewRatio=4        设置老年代与年轻代(包括1个Eden和2个Survivor区)的比值
-XX:+UseAdaptiveSizePolicy         自动选择各区大小比例
-XX:PretenureSizeThreadshold=1024  设置让大于此阈值的对象直接分配在老年代，单位为字节，只对Serial、ParNew收集器有效
-XX:MaxTenuringThreshold=15 	   默认值为15，新生代每次MinorGC后，还存活的对象年龄+1，当对象的年龄大于设置的这个值时就进入老年代
-XX:PrintTenuringDistribution      JVM在每次MinorGC后打印出当前使用的Survivor对象的年龄分布
-XX:TargetSurvivorRatio			   MinorGC结束后Survivor区域占用空间的期望比例

# 方法区
## 永久代
-XX:PermSize=256m 	 设置永久代初始值为256M
-XX:MaxPermSize=256m 设置永久代最大值为256M
## 元空间
-XX:MetaspaceSize 				初始空间大小
-XX:MaxMetaspaceSize 			最大空间，默认没有限制
-XX:+UseCompessedOops 			压缩对象指针
-XX:+UseCompressedClassPointers 压缩类指针
-XX:CompressedClassSpaceSize 	设置Klass Metaspace的大小，默认1G

# 直接内存
-XX:MaxDirectMemorySize 指定DirectMemory容量，若未指定，则默认与Java堆最大值一样
```

### 10.3.3 OutOfMemory选项

```shell
-XX:+HeapDumponoutfMonoyfror  表示在内存出现OOM的时候，把Heap转存(Dump)到文件以便后续分析
-XX:+HeapDumpBeforeFullGC	  表示在出现FullGC之前，生成Heap转储文件
-XX:HeapDumpPath=<path>  	  指定heap转存文件的存储路径
-XX:OnOutOfMemoryError 		  指定一个可行性程序或者脚本的路径，当发生OOM的时候，去执行这个脚本
```

### 10.3.4 垃圾收集器相关选项

```shell
# serial 串行 client模式下默认的垃圾回收器
-XX:+UseSerialGC 新生代使用Serial GC，老年代使用Serial Old GC
```

### 10.3.5 GC日志相关选项

```shell
# 常用参数
-verbose:gc 			输出gc日志信息，默认输出到标准输出
-XX:+PrintGC 			等同于-verbose:gc，表示打开简化的GC日志
-XX:+PrintGCDetails 	在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况
-XX:+PrintGCTimeStamps 	输出GC发生时的时间戳
-XX:+PrintGCDateStamps 	输出GC发生时的时间戳(以日期的形式，如2013-05-04T21:53:59.234+0800)
-XX:+PrintHeapAtGC 		每一次GC前和GC后，都打印堆信息
-Xloggc:<file>			把GC日志写入到一个文件中去，而不是打印到标准输出中

# 其他参数
-XX:+TraceClassloading 					监控类的加载
-XX:+PrintGCApplicationStoppedTime 		打印GC时线程的停顿时间
-XX:+PrintGCApplicationConcurrentTime 	垃圾收集之前打印出应用未中断的执行时间
-XX:+PrintReferenceGC 					记录回收了多少种不同引用类型的引用
-XX:+PrintTenuringDistribution 			让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布
-XX:+UseGCLogFileRotation 				启用GC日志文件的自动转储
-XX:NumberOfGClogFiles=1 				GC日志文件的循环数目
-XX:GCLogFileSize=1M					控制GC日志文件的大小
```

### 10.3.6 其他

```shell
-XX:ReservedCodeCacheSize=[g|m|k]. -XX:lnitialCodeCacheSize=[g|m|k] 指定代码缓存的大小
-XX:+DisableExplicitGC 		禁止hotspot执行System.gc()，默认禁用
-XX:+UseCodeCacheFlushing 	使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况
-XX:+DoEscapeAnalysis 		开启逃逸分析
-XX:+UseBiasedLocking 		开启偏向锁
-XX:+UseLargePages 			开启使用大页面
-XX:+UseTLAB	 			使用TLAB，默认打开
-XX:+PrintTLAB 				打印TLAB的使用情况
-XX:TLABSize 				设置TLAB大小
```

## 10.4 通过Java代码获取JVM参数

```java
public class HeapSpacelnitial {
	public static void main(String[] args){
		//返回Java虚拟机中的堆内存总量
		long initialMemory = Runtime.getRuntime().totalMemory()/ 1024/ 1024;
		//返回Java虚拟机试图使用的最大堆内存量
		long maxMemory = Runtime.getRuntime().maxMemory()/ 1024/ 1024;
		System.out.println("-Xms :"+initialMemory +"M");
		System.out.println("-Xmx:"+ maxMemory + "M");
		System.out.print1n("系统内存大小为:"+maxMemory *4.e/1024+"G");
		System.out.println("系统内存大小为:"+initialMemory *64.e/1024 + "G");
	}
}
```

# 疑问：具体运行时的变量，方法，常量到底存放在哪？

## 1.java静态变量存放位置？

```
public statci final Student stu = new Student();
```

stu 在方法区；stu引用的对象在堆

Class对象是存放在堆区的，不是方法区，类的元数据（元数据并不是类的Class对象！Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的）才是存在方法区的

2.堆中不存放基本类型和对象引用，只存放对象本身？

  堆存放对象，对象中有对象变量，

https://m.imooc.com/wenda/detail/496796

## 2. 常量池、运行时常量池、字符串常量池

```
public class Review {
    public static void main(String[] args) {
        String info = "hello world";
        int a = 666;
        final int b = 66;
        int c = 36728;
    }
}
```

此代码编译以后，使用**javap -v Review.class**命令查看字节码

```
Classfile /D:/idea_projects/demo/target/classes/com/example/demo/Review.class
  Last modified 2020-11-21; size 561 bytes
  MD5 checksum 09914fecad4a776e7ac86d1a6fd43baa
  Compiled from "Review.java"
public class com.example.demo.Review
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #5.#26         // java/lang/Object."<init>":()V
   #2 = String             #27            // hello world
   #3 = Integer            36728
   #4 = Class              #28            // com/example/demo/Review
   #5 = Class              #29            // java/lang/Object
   #6 = Utf8               <init>
   #7 = Utf8               ()V
   #8 = Utf8               Code
   #9 = Utf8               LineNumberTable
  #10 = Utf8               LocalVariableTable
  #11 = Utf8               this
  #12 = Utf8               Lcom/example/demo/Review;
  #13 = Utf8               main
  #14 = Utf8               ([Ljava/lang/String;)V
  #15 = Utf8               args
  #16 = Utf8               [Ljava/lang/String;
  #17 = Utf8               info
  #18 = Utf8               Ljava/lang/String;
  #19 = Utf8               a
  #20 = Utf8               I
  #21 = Utf8               b
  #22 = Utf8               c
  #23 = Utf8               MethodParameters
  #24 = Utf8               SourceFile
  #25 = Utf8               Review.java
  #26 = NameAndType        #6:#7          // "<init>":()V
  #27 = Utf8               hello world
  #28 = Utf8               com/example/demo/Review
  #29 = Utf8               java/lang/Object
{
  public com.example.demo.Review();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/example/demo/Review;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=5, args_size=1
         0: ldc           #2                  // String hello world
         2: astore_1
         3: sipush        666
         6: istore_2
         7: bipush        66
         9: istore_3
        10: ldc           #3                  // int 36728
        12: istore        4
        14: return
      LineNumberTable:
        line 10: 0
        line 11: 3
        line 12: 7
        line 13: 10
        line 14: 14
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      15     0  args   [Ljava/lang/String;
            3      12     1  info   Ljava/lang/String;
            7       8     2     a   I
           10       5     3     b   I
           14       1     4     c   I
    MethodParameters:
      Name                           Flags
      args
}
SourceFile: "Review.java"
```

从字节码文件中可以看到**Constant Pool**。**也就是说，每个class文件，都有一个常量池**

第一个疑问：为什么都是int类型的数据，用的指令却不同？按照JVM的规范，根据int值范围采用不同的指令将int数值入栈。 

 第二个疑问：为什么666和66没有被放到常量池中？据了解，对于int类型，只有超过一定范围的int值，才会放到常量池中， 这也就解释了36728为何被放到了常量池中。

### 2.2 常量池

<img src="D:\myself\springboot-example\文档\typora\images\jvm10" alt="img" style="zoom:80%;" />



### 2.3 运行时常量池

在常量池中，可以看到都是用#1 #2 #3这些临时符号来表示。

当运行某个程序时候，JVM会把所有的字节码文件加入到内存当中，在经过链接、验证后，将#1 #2 #3这些符号全部转换成内存中的实际地址，放入到运行时常量池运行。

**运行时常量池是放在方法区中的，全局只有一份，是一个被所有的class共享的区域**。

### 2.4 字符串常量池

```java
String a = "test1";
String b = "test2";
```

这两个字符串"test1"和"test2"在编译完成后，首先存放在常量池中。

在程序运行时，加载进入内存以后，字符串就会加载进入到字符串常量池中。jdk1.7以后，字符串常量池位于堆中。

## 3.栈帧

1. 局部变量表

   方法参数和方法体中的局部变量。在方法执行过程中，jvm使用局部变量表完成参数值到参数变量列表的传递过程

2. 操作数栈

3. 动态链接

   每个栈帧都有一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。

   Class文件的常量池存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。
   这些符号引用一部分在类加载阶段或者第一次使用时转化为直接引用，这种转化称为**静态解析**。
   另外一部分将在每一次运行时转化为直接引用，这部分称为**动态连接**

4. 方法返回地址

5. 附加信息

   虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧中，例如与调式有关的信息。这部分信息取决于虚拟机的实现。











