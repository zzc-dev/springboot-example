# 一、特性

1. 非关系型的键值对数据库，可以根据键以O(1)的时间复杂度查找或插入关联值

   > 整个key-value是hash表存储

2. Redis的数据是存在内存中的，性能高

3. 键的类型是唯一的，可以是字符串、整形、浮点型

4. 值的类似可以是：string、list、set、sorted set、hash

5. Redis内置了复制、磁盘持久化、LUA脚本、事务、客户端代理等功能

6. 通过哨兵和自动分区提供高可用性

7. 单线程每秒数十万级别的处理能力

## 1. 快速的redis有哪些慢操作

1. redis的hashtable扩容时，为了避免阻塞客户端请求，采用渐进式rehash，
   并且有两个hashtable，查询时先查新的，查不到在查旧的；插入在新的hash表，更新删除新旧都操作
2. 范围操作：返回集合的全部数据或者部分数据：HGETALL、SMEMBERS、LRANGE、ZRANGE，
   应尽量避免，可以使用SCAN改进

性能瓶颈：

 1. 单个请求耗时，阻塞了后面的请求

    a. 操作bigkey：插入分配内存、删除释放内存都十分耗时

    b. 使用复杂度过高的命令：事件复杂度O(n)

    c. 大量key集中过期：Redis的过期机制是在主线程中执行的

    d. 淘汰策略：也是在主线程上执行的

    e. AOF刷盘使用always机制：每次写入都需要把该操作刷到磁盘

    f. 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久

 2. 并发量非常大

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。

## 2. 高性能的IO模型--多路复用模型

>Redis单线程：主要是指网络IO和键值对读写是一个线程完成的。
>                   持久化、异步删除、集群数据同步是由额外的线程执行的。  

多线程问题：共享资源的并发访问+线程的上下文切换

**Redis单线程快的原因：**

​	<strong style="color:red">内存读写+高效的数据结构+多路复用IO模型</strong>

**多路复用IO模型：**

​    并发处理大量的客户端请求，提升吞吐量

### 2.1 单线程处理网络IO的问题

<img src="D:\myself\springboot-example\文档\typora\images\redis10.jpg" alt="img" style="zoom: 25%;" />



阻塞点：

	1. accept：Redis监听到一个连接请求，但一直未能成功建立连接
 	2. recv：Redis通过recv从一个客户端读取数据，如果数据一直无法到达

   以上两点都会导致Redis线程阻塞，无法处理其他客户端请求

 解决：使用Socket网络模型：支持非阻塞模式

### 2.2 非阻塞模式

在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字

<img src="D:\myself\springboot-example\文档\typora\images\redis11.jpg" alt="img" style="zoom: 25%;" />

调用accept和recv方法时，使用监听套接字监听，当连接请求或数据未到达时，Redis线程可以去处理其他事情，无需等待
当数据到达时，通过某种机制去通知Redis处理，这时，我们可以用到Linux的IO多路复用机制

### 2.3 基于多路复用的高性能I/O模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制

在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字

<img src="D:\myself\springboot-example\文档\typora\images\redis12.jpg" alt="img" style="zoom:25%;" />

Redis调用epoll，让内核监听这些套接字（FD）,一旦套接字上有请求达到时，根据事件调用相应的回调函数

## 3. 持久化

原因：数据存在内存中，一旦服务器宕机，内存数据将全部丢失

为什么不从数据库中同步：

1. 需要频繁访问数据库，给数据库带来巨大的压力

 	2. 读取数据库性能低

### 3.1 AOF

记录的是命令而不是数据

例如: 执行 set testkey testvalue，保存的是：

```
*3         当前命令有三个部分
$3         命令有几个字节
set
$7
testkey
$9
testvalue
```

**写回策略：**

	1. **always**：每次写操作同步写入磁盘
 	2. **EverySec**：每秒写回，每个写命令执行完，先吧日志写到AOF的内存缓冲区，每隔1秒把日志写入磁盘
 	3. **NO**：操作系统写回，每个写命令执行完，先吧日志写到AOF的内存缓冲区，由操作系统决定何时写入磁盘

主线程阻塞和数据丢失风险，无法做到两全其美

![img](D:\myself\springboot-example\文档\typora\images\redis13.jpg)

随着命令的执行，AOF日志文件会越来越大，性能也会受到影响：

	1. 磁盘文件的大小本身收到限制
 	2. 文件过大，每次写入性能降低
 	3. 服务宕机，恢复过程缓慢

**AOF日志重写机制：**

> AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入

​    <strong style="color:red">AOF重写会阻塞主线程吗</strong>

​    和AOF文件是由主线程写入不同，重写过程是后台子进程`berewriteaof`完成的。

**一个拷贝，两处日志**

“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

“两处日志”：因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 **AOF 日志**，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复

而第二处日志，就是指新的 **AOF 重写日志**。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。

​     <strong style="color:red">AOF fork子进程风险</strong>

1. fork这个瞬间一定是阻塞主线程的，fork不会一次性拷贝所有内存数据给子进程，而是采用操作系统提供的**写时复制（Copy-On-Write**）就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞

   但fork子进程需要拷贝进程必要的数据结构，其中有一项就是**拷贝内存页表**（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，**实例越大，内存页表越大，fork阻塞时间越久**。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。

2. fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。

   此时主线程仍然有数据写入，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。

   因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个**bigkey**，**重新申请大块内存耗时会变长**，可能会产阻塞风险。

   如果操作系统开启了**内存大页机制**(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。

   Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。

**如何触发AOF重写**：

 1. 手动执行命令：`bgrewriteaof`

 2. 通过配置文件自动触发

    ```
    1. auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB
    2. auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。
    
    AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。
    ```

    

**优缺点：**

   优点：每次操作只需记录命令，需要持久化的数据量不大

   缺点：进行故障恢复时，需要逐一把操作执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。

### 3.2 RDB

> **内存快照**：记录的是内存某一时刻的数据，在做故障恢复的时候，直接把数据读入内存即可，

<strong style="color:red">做快照时，数据还能被增删改吗？(主线程会被阻塞吗)</strong>

   Redis提供两个命令来生成RDB文件：

		1. **save**：在主线程中执行，会导致阻塞；
  		2. **bgsave**：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

使用bgsave生成rdb文件时，采用了**写时复制**，避免阻塞写请求

>与AOF一样，fork拷贝内存页表，主线程读操作不受影响，当有写操作时，并且key存在快照中时，主线程拷贝一份数据到新的内存，并把这个内存地址置为主线程的虚拟内存地址执向它，这样，父子进程内存真正分离，主线程的写请求也不会受到影响。

**快照生成的频率**

​	频繁地执行全量快照，也会带来两方面的开销。

    1. 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环
       2. bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了

**增量快照：**

> **Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照**

**如何触发RDB**

1. shutdown(正常关闭)时，如果没有开启aof，会触发；

2. redis.conf默认配置(此配置是针对bgsave)

   根据这个默认配置，会丢数据；意外宕机的情况下，丢失最后一次持久化后的数据

   ```mysql
   save 900 1  #900s检查一次，增量的数据变更命令超过1，就触发；
   save 300 10 #300s检查一次 更改10次
   sava 60 10000 #60s检查一次  更改命令1w条，就触发；
   ```

3. 执行命令save或者bgsave

4. 执行**flushall命令**，清空rdb(Redis默认16个库都清空)；但是里面是空的，无意义

**关于 AOF 和 RDB 的选择问题的建议**：

1. 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
2. 如果允许分钟级别的数据丢失，可以只使用 RDB；
3. 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡