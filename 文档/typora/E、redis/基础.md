# 一、特性

1. 非关系型的键值对数据库，可以根据键以O(1)的时间复杂度查找或插入关联值

   > 整个key-value是hash表存储

2. Redis的数据是存在内存中的，性能高

3. 键的类型是唯一的，可以是字符串、整形、浮点型

4. 值的类似可以是：string、list、set、sorted set、hash

5. Redis内置了复制、磁盘持久化、LUA脚本、事务、客户端代理等功能

6. 通过哨兵和自动分区提供高可用性

7. 单线程每秒数十万级别的处理能力

## 1. 快速的redis有哪些慢操作

1. redis的hashtable扩容时，为了避免阻塞客户端请求，采用渐进式rehash，
   并且有两个hashtable，查询时先查新的，查不到在查旧的；插入在新的hash表，更新删除新旧都操作
2. 范围操作：返回集合的全部数据或者部分数据：HGETALL、SMEMBERS、LRANGE、ZRANGE，
   应尽量避免，可以使用SCAN改进

性能瓶颈：

 1. 单个请求耗时，阻塞了后面的请求

    a. 操作bigkey：插入分配内存、删除释放内存都十分耗时

    b. 使用复杂度过高的命令：事件复杂度O(n)

    c. 大量key集中过期：Redis的过期机制是在主线程中执行的

    d. 淘汰策略：也是在主线程上执行的

    e. AOF刷盘使用always机制：每次写入都需要把该操作刷到磁盘

    f. 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久

 2. 并发量非常大

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。

## 2. 高性能的IO模型--多路复用模型

>Redis单线程：主要是指网络IO和键值对读写是一个线程完成的。
>                   持久化、异步删除、集群数据同步是由额外的线程执行的。  

多线程问题：共享资源的并发访问+线程的上下文切换

**Redis单线程快的原因：**

​	<strong style="color:red">内存读写+高效的数据结构+多路复用IO模型</strong>

**多路复用IO模型：**

​    并发处理大量的客户端请求，提升吞吐量

### 2.1 单线程处理网络IO的问题

<img src="D:\myself\springboot-example\文档\typora\images\redis10.jpg" alt="img" style="zoom: 25%;" />



阻塞点：

	1. accept：Redis监听到一个连接请求，但一直未能成功建立连接
 	2. recv：Redis通过recv从一个客户端读取数据，如果数据一直无法到达

   以上两点都会导致Redis线程阻塞，无法处理其他客户端请求

 解决：使用Socket网络模型：支持非阻塞模式

### 2.2 非阻塞模式

在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字

<img src="D:\myself\springboot-example\文档\typora\images\redis11.jpg" alt="img" style="zoom: 25%;" />

调用accept和recv方法时，使用监听套接字监听，当连接请求或数据未到达时，Redis线程可以去处理其他事情，无需等待
当数据到达时，通过某种机制去通知Redis处理，这时，我们可以用到Linux的IO多路复用机制

### 2.3 基于多路复用的高性能I/O模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制

在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字

<img src="D:\myself\springboot-example\文档\typora\images\redis12.jpg" alt="img" style="zoom:25%;" />

Redis调用epoll，让内核监听这些套接字（FD）,一旦套接字上有请求达到时，根据事件调用相应的回调函数

## 3. 持久化

原因：数据存在内存中，一旦服务器宕机，内存数据将全部丢失

为什么不从数据库中同步：

1. 需要频繁访问数据库，给数据库带来巨大的压力

 	2. 读取数据库性能低

### 3.1 AOF

记录的是命令而不是数据

例如: 执行 set testkey testvalue，保存的是：

```
*3         当前命令有三个部分
$3         命令有几个字节
set
$7
testkey
$9
testvalue
```

**写回策略：**

	1. **always**：每次写操作同步写入磁盘
 	2. **EverySec**：每秒写回，每个写命令执行完，先吧日志写到AOF的内存缓冲区，每隔1秒把日志写入磁盘
 	3. **NO**：操作系统写回，每个写命令执行完，先吧日志写到AOF的内存缓冲区，由操作系统决定何时写入磁盘

主线程阻塞和数据丢失风险，无法做到两全其美

![img](D:\myself\springboot-example\文档\typora\images\redis13.jpg)

随着命令的执行，AOF日志文件会越来越大，性能也会受到影响：

	1. 磁盘文件的大小本身收到限制
 	2. 文件过大，每次写入性能降低
 	3. 服务宕机，恢复过程缓慢

**AOF日志重写机制：**

> AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入

​    <strong style="color:red">AOF重写会阻塞主线程吗</strong>

​    和AOF文件是由主线程写入不同，重写过程是后台子进程`berewriteaof`完成的。

**一个拷贝，两处日志**

“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

“两处日志”：因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复

而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。









