# 一、进程与线程

## 1.1 进程

程序由指令和数据组成。这些指令要运行，数据要读写，就必须将指令加载到CPU，数据加载到内存。
在指令运行过程中还需要用到磁盘、网络等设备。
进程就是用来加载指令、管理内存、管理IO的。

当一个程序被运行，从磁盘加载这个程序到内存，这时就开启了一个进程

进程可以视为程序的一个实例。

## 1.2 线程

一个进程可以拥有多个线程，但一个线程只能属于一个进程。

一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行

java中，线程作为资源调度的最小单位，进程作为资源分配的最小单位。
在windows中进程是不活动的，只是作为线程的容器。

## 1.3 对比

1. 进程基本上互相独立，而线程存在于进程中，是进程的一个子集

2. 进程拥有共享的资源，如内存空间等，供期内部的线程共享

3. 进程间通信较为复杂

     同一台计算机的进程通信称为IPC
    不同计算机的进程通信，需要通过网络，并遵守相同的协议，如http

4. 线程通信相对简单，内部共享进程的内存，可以访问同一个共享变量

5. 线程更轻量，切换上下文代价比进程小

## 1.4 并发与并行

**并发** (concurrent) 是同一时间应对（dealing with）多件事情的能力

**并行** (parallel) 是同一时间动手做（doing）多件事情的能力 

## 1.5 查看 or 杀死 运行线程

**windows**

​	tasklist  [| findStr java]

​	taskkill  /F /PID  <pid>

**java**

​	jps 查看所有java进程

​	jstack <PID> 查看某个java进程的所有线程状态

​	jconsole 查看某个java进程中线程的运行情况

**linux**

​	ps -ef  查看所有进程
​	ps -fT -p <PID> 查看某个进程
​	top -H -p <PID> 查看进程下所有的线程

# 二、基础

## 2.1 sleep与yield

sleep

1. 线程状态由running -> timed waiting -> runnable
2. 其他线程可中断其睡眠，使其抛出InterruptedException异常
3. 建议使用TimeUnit的sleep代替Thread的sleep来获得更好的可读性

yield

	1. 线程状态由running -> runnable

## 2.2 两阶段中止模式

# 三、Synchronized

synchronized实际上利用对象保证了临界区代码的原子性，临界区内的代码在外界看来是不可分割的，不会被线程切换所打断

## 3.1 变量的线程安全分析

 **成员变量和静态变量的线程安全分析**

- 如果没有变量没有在线程间共享，那么变量是安全的
- 如果变量在线程间共享
  - 如果只有读操作，则线程安全
  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全

**局部变量线程安全分析**

​	**<strong style="color:red">局部变量的逸出问题</strong>**

- 局部变量【局部变量被初始化为基本数据类型】是安全的
- 局部变量引用的对象未必是安全的
  - 如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的
  - 如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的

## 3.2 mark word

![1583651590160](D:\myself\springboot-example\文档\typora\images\juc08.png)

## 3.3 Monitor

>重量级锁：mark work :  ptr_to_heavyweight_monitor:30  |  00
>                                           指向monitor对象的地址

### 3.3.1 Java对象头

以 32 位虚拟机为例,普通对象的对象头结构如下，其中的**Klass Word为指针，指向对应的Class对象**

​	       普通对象

![1583651065372](D:\myself\springboot-example\文档\typora\images\juc06.png)

​	     数组对象

![1583651088663](D:\myself\springboot-example\文档\typora\images\juc07.png)

   **Mark Word**

  ![1583651590160](D:\myself\springboot-example\文档\typora\images\juc08.png)

所以一个对象的结构如下：

<img src="D:\myself\springboot-example\文档\typora\images\juc09.png" alt="1583678624634"  />

### 3.3.2 monitor原理

Monitor被翻译为监视器或者说管程

每个java对象都可以关联一个Monitor，如果使用`synchronized`给对象上锁（重量级），该对象头的Mark Word中就被设置为指向Monitor对象的指针

![1583652360228](D:\myself\springboot-example\文档\typora\images\juc10.png)

- 刚开始时Monitor中的Owner为null
- 当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner
- 当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入EntryList中变成BLOCKED状态
- Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的
- 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析

> 注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果不加 synchronized 的对象不会关联监视器，不遵从以上规则

```
static final Object lock=new Object();
    static int counter = 0;
    public static void main(String[] args) {
        synchronized (lock) {
            counter++;
        }
    }
```

```
 0 getstatic #2 <com/concurrent/test/Test17.lock>
 # 取得lock的引用（synchronized开始了）
 3 dup    
 # 复制操作数栈栈顶的值放入栈顶，即复制了一份lock的引用
 4 astore_1
 # 操作数栈栈顶的值弹出，即将lock的引用存到局部变量表中
 5 monitorenter
 # 将lock对象的Mark Word置为指向Monitor指针
 6 getstatic #3 <com/concurrent/test/Test17.counter>
 9 iconst_1
10 iadd
11 putstatic #3 <com/concurrent/test/Test17.counter>
14 aload_1
# 从局部变量表中取得lock的引用，放入操作数栈栈顶
15 monitorexit
# 将lock对象的Mark Word重置，唤醒EntryList
16 goto 24 (+8)
# 下面是异常处理指令，可以看到，如果出现异常，也能自动地释放锁
19 astore_2
20 aload_1
21 monitorexit
22 aload_2
23 athrow
24 return
```

## 3.4 轻量级锁

> mark work : ptr_to_lock_record:30  | 00

轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是`synchronized`，假设有两个方法同步块，利用同一个对象加锁

```
static final Object obj = new Object();
public static void method1() {
     synchronized( obj ) {
         // 同步块 A
         method2();
     }
}
public static void method2() {
     synchronized( obj ) {
         // 同步块 B
     }
}
```

1. 每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的Mark Word和对象引用reference

   <img src="D:\myself\springboot-example\文档\typora\images\juc11.png" alt="1583755737580" style="zoom: 67%;" />

2. 让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中

   <img src="D:\myself\springboot-example\文档\typora\images\juc12.png" alt="1583755888236" style="zoom: 67%;" />

3. 如果cas替换成功，那么对象的对象头储存的就是锁记录的地址和状态01，如下所示

   <img src="D:\myself\springboot-example\文档\typora\images\juc13.png" alt="1583755964276" style="zoom:67%;" />

4. 如果cas失败，有两种情况

   1. 如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入**锁膨胀**阶段

   2. 如果是自己的线程已经执行了synchronized进行加锁，那么那么再添加一条 Lock Record 作为重入的计数

      <img src="D:\myself\springboot-example\文档\typora\images\juc14.png" alt="1583756190177" style="zoom:67%;" />

5. 当线程退出synchronized代码块的时候，**如果获取的是取值为 null 的锁记录 **，表示有重入，这时重置锁记录，表示重入计数减一

   <img src="D:\myself\springboot-example\文档\typora\images\juc15.png" alt="1583756357835" style="zoom:67%;" />

6. 当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象

   1. 成功则解锁成功
   2. 失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

### 3.4.1 锁膨胀

如果在尝试加轻量级锁的过程中，cas操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将**轻量级锁变成重量级锁**

1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁

   <img src="D:\myself\springboot-example\文档\typora\images\juc16.png" alt="1583757433691" style="zoom:67%;" />

2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程

   即为对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor 的EntryList 变成BLOCKED状态

   <img src="D:\myself\springboot-example\文档\typora\images\juc17.png" alt="1583757586447" style="zoom:67%;" />

3. 当Thread-0 退出synchronized同步块时，使用cas将Mark Word的值恢复给对象头，失败，那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList 中的Thread-1线程

## 3.5 自旋优化

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁

自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁，就真正开始创建monitor

自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能

## 3.6 偏向锁

> mark word :  thread:23 | epoch:2 | age:4 | biased_lock:1 | 01

在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS操作，这是有点耗时滴，那么java6开始引入了偏向锁的东东，只有第一次使用CAS时将对象的Mark Word头设置为入锁线程ID，**之后这个入锁线程再进行重入锁时，发现线程ID是自己的，那么就不用再进行CAS了**

![1583760728806](D:\myself\springboot-example\文档\typora\images\juc18.png)

**普通对象mark word以001结尾，偏向锁对象以101结尾**

一个对象的创建过程

1. 如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的Thread，epoch，age都是0，在加锁的时候进行设置这些的值.
2. **偏向锁默认是延迟的**，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-`XX:BiasedLockingStartupDelay=0`来禁用延迟
3. 注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中
4. 禁用偏向锁：` -XX:-UseBiasedLocking` 

### 3.6.1 撤销偏向锁

1.  `hashCode`：当调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存`hashcode`的值了

2. #####  调用 wait/notify 会使对象的锁变成重量级锁，因为wait/notify方法之后重量级锁才支持

### 3.6.2 批量重偏向

如果对象被多个线程访问，但是没有竞争，这时候偏向了线程一的对象又有机会重新偏向线程二，即可以不用升级为轻量级锁，

可这和我们之前做的实验矛盾了呀，其实要实现重新偏向是要有条件的：

就是超过20对象对同一个线程如线程一撤销偏向时，那么第20个及以后的对象才可以将撤销对线程一的偏向这个动作变为将第20个及以后的对象偏向线程二

​	对于Dog对象：

		1. t1线程下的dog对象全部是偏向锁：偏向t1

```
Vector<Dog> list = new Vector<Dog>();
Thread t = new Thread(() ->{
	@Overried
	pubic void run(){
		for(int i=0;i<50;i++){
			Dog o = new Dog();
			synchronized(o){
				list.add(o);
			}
		}
	}
}, "t1");
```

2. t1线程执行完毕，执行t2,此时，list中的dog对象 0-18 偏向锁升为轻量级锁；19-29 批量重偏向为t2的偏向锁

```
Thread t = new Thread(() ->{
	@Overried
	pubic void run(){
		for(int i=0;i<30;i++){
			Dog o = list.get(i);
			synchronized(o){
				list.add(o);
			}
		}
	}
}, "t2");
```

3. t1、t2全部执行完成，执行t3，list中dog对象 30-38 批量重偏向为t3的偏向锁，39-49全部转为轻量级锁

```
Thread t = new Thread(() ->{
	@Overried
	pubic void run(){
		for(int i=30;i<50;i++){
			Dog o = list.get(i);
			synchronized(o){
				list.add(o);
			}
		}
	}
}, "t3");
```

4. 超过40个dog对象批量重偏向会导致以后所有的dog对象无偏向锁

## 3.7 锁升级

偏向锁 -> 批量重偏向 -> 轻量级锁 -> 重量级锁

# 模式

## 1. 两阶段中止模式

## 2. 同步模式之保护性暂停

在一个线程等待另一个线程的执行结果，要点：

1. 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 Object
2. 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）
3. JDK 中，join 的实现、Future 的实现，采用的就是此模式
4. 因为要等待另一方的结果，因此归类到同步模式











