https://my.oschina.net/xianggao/blog/548896

```java
SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
```

# 一、SqlSessionFactoryBuilder

```java
public class SqlSessionFactoryBuilder {

    //Reader读取mybatis配置文件，传入构造方法
    //除了Reader外，其实还有对应的inputStream作为参数的构造方法，
    //这也体现了mybatis配置的灵活性
    public SqlSessionFactory build(Reader reader) {
        return build(reader, null, null);
    }

    public SqlSessionFactory build(Reader reader, String environment) {
        return build(reader, environment, null);
    }
  
    //mybatis配置文件 + properties, 此时mybatis配置文件中可以不配置properties，也能使用${}形式
    public SqlSessionFactory build(Reader reader, Properties properties) {
        return build(reader, null, properties);
    }
  
    //通过XMLConfigBuilder解析mybatis配置，然后创建SqlSessionFactory对象
    public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
        try {
            XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
            //下面看看这个方法的源码
            return build(parser.parse());
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error building SqlSession.", e);
        } finally {
            ErrorContext.instance().reset();
            try {
                reader.close();
            } catch (IOException e) {
                // Intentionally ignore. Prefer previous error.
            }
        }
    }
    
    public SqlSessionFactory build(Configuration config) {
        return new DefaultSqlSessionFactory(config);
    }
}
```



# 二、XMLConfigBuilder 解析配置文件

## 2.1 构造函数

```java
    public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {
        this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);
    }

    private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
        super(new Configuration());
        ErrorContext.instance().resource("SQL Mapper Configuration");
        this.configuration.setVariables(props); // 1.java初始化Builder传递的配置
        this.parsed = false;
        this.environment = environment;
        this.parser = parser;
    }
```

## 2.2 parse

```java
 //外部调用此方法对mybatis配置文件进行解析
    public Configuration parse() {
        if (parsed) {
            throw new BuilderException("Each XMLConfigBuilder can only be used once.");
        }
        parsed = true;
        //从根节点configuration
        parseConfiguration(parser.evalNode("/configuration"));
        return configuration;
    }

    //此方法就是解析configuration节点下的子节点
    //由此也可看出，我们在configuration下面能配置的节点为以下10个节点
    private void parseConfiguration(XNode root) {
        try {
            propertiesElement(root.evalNode("properties")); //issue #117 read properties first
            typeAliasesElement(root.evalNode("typeAliases"));
            pluginElement(root.evalNode("plugins"));
            objectFactoryElement(root.evalNode("objectFactory"));
            objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
            settingsElement(root.evalNode("settings"));
            environmentsElement(root.evalNode("environments"));
            databaseIdProviderElement(root.evalNode("databaseIdProvider"));
            typeHandlerElement(root.evalNode("typeHandlers"));
            mapperElement(root.evalNode("mappers"));
        } catch (Exception e) {
            throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
        }
    }
```

>1. configuration节点为根节点。
>
>2. 在configuration节点之下，我们可以配置10个子节点， 
>
>   分别为：properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers。

## 2.3 propertiesElement 解析properties

**配置**

```xml
    <!-- 方法一： 从外部指定properties配置文件, 除了使用resource属性指定外，还可通过url属性指定url  
        <properties resource="dbConfig.properties"></properties> 
    -->
    <!-- 方法二： 直接配置为xml -->
    <properties>
        <property name="driver" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/test1"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </properties>
```

​		[方法三](##2.1 构造函数)

三种方法的加载顺序：

			1. 方法三（java代码）初始化时加入configuration          this.configuration.setVariables(props);
   			2. 在下面代码先加载xml的配置到default                          Properties defaults = context.getChildrenAsProperties();
            			3. 加载外部指定配置文件（方法一）覆盖default             defaults.putAll(Resources.getUrlAsProperties(url));
                  			4. 把configuration覆盖加入default                                   defaults.putAll(vars);
            			5. configuration.setVariables(defaults);

  <strong style="color:red">**优先级：java代码Porperties对象 > 外部指定配置 >  xml配置**</strong>

```java
	private void propertiesElement(XNode context) throws Exception {
        if (context != null) {
            // 方法二
            Properties defaults = context.getChildrenAsProperties();
            // 获取properties节点上 resource属性的值
            String resource = context.getStringAttribute("resource");
            // 获取properties节点上 url属性的值, resource和url不能同时配置
            String url = context.getStringAttribute("url");
            if (resource != null && url != null) {
                throw new BuilderException("The properties element cannot specify both a URL and a resource based property file 					reference.  Please specify one or the other.");
            }
            // 把解析出的properties文件set进Properties对象
            if (resource != null) {
                defaults.putAll(Resources.getResourceAsProperties(resource));
            } else if (url != null) {
                defaults.putAll(Resources.getUrlAsProperties(url));
            }
            // 将configuration对象中已配置的Properties属性与刚刚解析的融合
            // configuration这个对象会装载所解析mybatis配置文件的所有节点元素，以后也会频频提到这个对象
            // 既然configuration对象用有一系列的get/set方法， 那是否就标志着我们可以使用java代码直接配置？ 
            // 答案是肯定的， 不过使用配置文件进行配置，优势不言而喻
            Properties vars = configuration.getVariables();  // 1. 得到构建sqlSessionFactoryBuilder传递的properties参数
            if (vars != null) {
                defaults.putAll(vars);
            }
            // 把装有解析配置propertis对象set进解析器， 因为后面可能会用到
            parser.setVariables(defaults);
            // set进configuration对象
            configuration.setVariables(defaults);
        }
    }
```

## 2.4 environmentsElement 解析environments

```xml
<environments default="development">
    <environment id="development">
        <!-- 
        JDBC–这个配置直接简单使用了JDBC的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。
        MANAGED–这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期（比如Spring或JEE应用服务器的上下文）。
        -->
        <transactionManager type="JDBC"/>
        <!--
        UNPOOLED–这个数据源的实现是每次被请求时简单打开和关闭连接
        POOLED–mybatis实现的简单的数据库连接池类型，它使得数据库连接可被复用，不必在每次请求时都去创建一个物理的连接。
        JNDI – 通过jndi从tomcat之类的容器里获取数据源。
        -->
        <dataSource type="POOLED">  
            <!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 -->
            <property name="driver" value="${driver}"/>
            <property name="url" value="${url}"/>
            <property name="username" value="${username}"/>
            <property name="password" value="${password}"/>  
        </dataSource>
    </environment>
    
    <!-- 我再指定一个environment -->
    <environment id="test">
        ...
    </environment>
</environments>
```

1. 根据default得到运行的环境
2. 配置事务  **mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务，配置为MANAGED则是将事务托管给容器，** 
3. 得到DataSource
4. 将environment配置加入configuration

```java
    private void environmentsElement(XNode context) throws Exception {
        if (context != null) {
            if (environment == null) {
                //解析environments节点的default属性的值
                //例如: <environments default="development">
                environment = context.getStringAttribute("default");
            }
            //递归解析environments子节点
            for (XNode child : context.getChildren()) { 
                String id = child.getStringAttribute("id");
                //isSpecial就是根据由environments的default属性去选择对应的enviroment
                if (isSpecifiedEnvironment(id)) {
                    //事务， mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务，配置为MANAGED则是将事务托管给容器， 
                    TransactionFactory txFactory = transactionManagerElement(child.evalNode("transactionManager"));
                    //enviroment节点下面就是dataSource节点了，解析dataSource节点（下面会贴出解析dataSource的具体方法）
                    DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource"));
                    DataSource dataSource = dsFactory.getDataSource();
                    Environment.Builder environmentBuilder = new Environment.Builder(id)
                          .transactionFactory(txFactory)
                          .dataSource(dataSource);
                    //老规矩，会将dataSource设置进configuration对象
                    configuration.setEnvironment(environmentBuilder.build());
                }
            }
        }
    }
```

### 2.4.1 dataSourceElement 解析dataSource

```java
    private DataSourceFactory dataSourceElement(XNode context) throws Exception {
        if (context != null) {
            //dataSource的连接池
            String type = context.getStringAttribute("type");
            //子节点 name, value属性set进一个properties对象
            Properties props = context.getChildrenAsProperties();
            //创建dataSourceFactory
            DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();
            factory.setProperties(props);
            return factory;
        }
        throw new BuilderException("Environment declaration requires a DataSourceFactory.");
    } 
```

## 2.5 typeAliasesElement 自定义别名

```xml
  	<typeAliases>
        <!--
        通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean,
        并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。
        也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) 
        <package name="com.dy.entity"/>
        -->
        <typeAlias alias="UserEntity" type="com.dy.entity.User"/>
    </typeAliases>
```



```java
private void typeAliasesElement(XNode parent) {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            //如果子节点是package, 那么就获取package节点的name属性， mybatis会扫描指定的package
            if ("package".equals(child.getName())) {
                String typeAliasPackage = child.getStringAttribute("name");
                //TypeAliasRegistry 负责管理别名， 这儿就是通过TypeAliasRegistry 进行别名注册， 下面就会看看TypeAliasRegistry源码
                configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
            } else {
                //如果子节点是typeAlias节点，那么就获取alias属性和type的属性值
                String alias = child.getStringAttribute("alias");
                String type = child.getStringAttribute("type");
                try {
                    Class<?> clazz = Resources.classForName(type);
                    if (alias == null) {
                        typeAliasRegistry.registerAlias(clazz);
                    } else {
                        typeAliasRegistry.registerAlias(alias, clazz);
                    }
                } catch (ClassNotFoundException e) {
                    throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
                }
            }
        }
    }
}
```

## 2.6 typeHandlerElement 

```xml
 <typeHandlers>
      <!-- 
          当配置package的时候，mybatis会去配置的package扫描TypeHandler
          <package name="com.dy.demo"/>
       -->
      <typeHandler javaType="" jdbcType="" handler=""/>
      
  </typeHandlers>
```

该方法就是通过解析javaType、jdbcType、TypeHandler放到typeHandlerRegistry的map中

```java
private void typeHandlerElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        //子节点为package时，获取其name属性的值，然后自动扫描package下的自定义typeHandler
        if ("package".equals(child.getName())) {
          String typeHandlerPackage = child.getStringAttribute("name");
          typeHandlerRegistry.register(typeHandlerPackage);
        } else {
          String javaTypeName = child.getStringAttribute("javaType");
          String jdbcTypeName = child.getStringAttribute("jdbcType");
          //handler就是我们配置的typeHandler
          String handlerTypeName = child.getStringAttribute("handler");
          //resolveClass方法就是我们上篇文章所讲的TypeAliasRegistry里面处理别名的方法
          Class<?> javaTypeClass = resolveClass(javaTypeName);
          //JdbcType是一个枚举类型，resolveJdbcType方法是在获取枚举类型的值
          JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
          Class<?> typeHandlerClass = resolveClass(handlerTypeName);
          //注册typeHandler, typeHandler通过TypeHandlerRegistry这个类管理
          if (javaTypeClass != null) {
            if (jdbcType == null) {
              typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);
            } else {
              typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);
            }
          } else {
            typeHandlerRegistry.register(typeHandlerClass);
          }
        }
      }
    }
}
```

## 2.7 objectFactoryElement

`MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成`。`默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化`。

自定义ObjectFactory

```xml
<objectFactory type="org.mybatis.example.ExampleObjectFactory">
        <property name="someProperty" value="100"/>
</objectFactory>
```

```java
private void objectFactoryElement(XNode context) throws Exception {
  if (context != null) {
    String type = context.getStringAttribute("type");
    Properties properties = context.getChildrenAsProperties();
    ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();
    factory.setProperties(properties);
    configuration.setObjectFactory(factory);
  }
}
```

## 2.8 pluginElement

plugins 是一个可选配置。`mybatis中的plugin其实就是个interceptor`， 它可以拦截Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler 的部分方法，处理我们自己的逻辑。

- `Executor` 就是真正执行sql语句的东西，
- ` ParameterHandler` 使用`TypeHandler`处理传入参数
- `ResultSetHandler` 就是处理返回结果的

```xml
    <plugins>
      <plugin interceptor="org.mybatis.example.ExamplePlugin">
        <property name="someProperty" value="100"/>
      </plugin>
    </plugins>
```



```java
  private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        String interceptor = child.getStringAttribute("interceptor");
        Properties properties = child.getChildrenAsProperties();
        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
        interceptorInstance.setProperties(properties);
        configuration.addInterceptor(interceptorInstance);
      }
    }
  }
```

## 2.9 mapperElement

```xml
    <mappers>
        <!-- 第一种方式：通过resource指定 -->
        <mapper resource="com/dy/dao/userDao.xml"/>
    
        <!-- 第二种方式， 通过class指定接口，进而将接口与对应的xml文件形成映射关系
             不过，使用这种方式必须保证 接口与mapper文件同名(不区分大小写)， 
             我这儿接口是UserDao,那么意味着mapper文件为UserDao.xml 
        <mapper class="com.dy.dao.UserDao"/>
        -->
      
        <!-- 第三种方式，直接指定包，自动扫描，与方法二同理 
        <package name="com.dy.dao"/>
        -->
        <!-- 第四种方式：通过url指定mapper文件位置
        <mapper url="file://........"/>
        -->
    </mappers>
```

`所谓的mapper映射文件，就是让mybatis 用来建立数据表和javabean映射的一个桥梁`。

在我们实际开发中，`通常一个mapper文件对应一个dao接口， 这个mapper可以看做是dao的实现`。所以,mappers必须配置。

## 2.10 settingsElement

```xml
<settings> 
    <setting name="cacheEnabled" value="true"/> 
    <setting name="lazyLoadingEnabled" value="true"/> 
    <setting name="multipleResultSetsEnabled" value="true"/> 
    <setting name="useColumnLabel" value="true"/> 
    <setting name="useGeneratedKeys" value="false"/> 
    <setting name="enhancementEnabled" value="false"/> 
    <setting name="defaultExecutorType" value="SIMPLE"/> 
    <setting name="defaultStatementTimeout" value="25000"/> 
</settings>
```

setting节点里配置的值会直接改写Configuration对应的变量值，这些变量描述的是Mybatis的全局运行方式

```java
  private void settingsElement(Properties props) throws Exception {
    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty("autoMappingBehavior", "PARTIAL")));
    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty("autoMappingUnknownColumnBehavior", "NONE")));
    configuration.setCacheEnabled(booleanValueOf(props.getProperty("cacheEnabled"), true));
    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty("proxyFactory")));
	...
  }
```

<img src="D:\myself\springboot-example\文档\typora\images\mybatis01.png" alt="è¾å¥å¾çè¯´æ" style="zoom:50%;" />

# 三、**TypeAliasRegistry** 

## 3.1 成员变量 TYPE_ALIASES 

```java
  //这就是核心所在啊， 原来别名就仅仅通过一个HashMap来实现， key为别名， value就是别名对应的类型（class对象）
  private final Map<String, Class<?>> TYPE_ALIASES = new HashMap<String, Class<?>>();
```

## 3.2 构造器

```java
  /**
   * 以下就是mybatis默认为我们注册的别名
   */
  public TypeAliasRegistry() {
    registerAlias("string", String.class);

    registerAlias("byte", Byte.class);
    registerAlias("long", Long.class);
    registerAlias("short", Short.class);
    registerAlias("int", Integer.class);
    registerAlias("integer", Integer.class);
    registerAlias("double", Double.class);
    registerAlias("float", Float.class);
    registerAlias("boolean", Boolean.class);
    ....
  }
```

## 3.3 registerAliases(String packageName)

```java
  /**
   * 配置文件中配置为package的时候， 会调用此方法，根据配置的报名去扫描javabean ，然后自动注册别名
   * 默认会使用 Bean 的首字母小写的非限定类名来作为它的别名
   * 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user)
   */
  public void registerAliases(String packageName){
    registerAliases(packageName, Object.class);
  }

  public void registerAliases(String packageName, Class<?> superType){
    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<Class<?>>();
    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
    Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();
    for(Class<?> type : typeSet){
      // Ignore inner classes and interfaces (including package-info.java)
      // Skip also inner classes. See issue #6
      if (!type.isAnonymousClass() && !type.isInterface() && !type.isMemberClass()) {
        registerAlias(type);
      }
    }
  }
```

## 3.4 registerAlias

```java
  public void registerAlias(Class<?> type) {
    String alias = type.getSimpleName();
    Alias aliasAnnotation = type.getAnnotation(Alias.class);
    if (aliasAnnotation != null) {
      alias = aliasAnnotation.value();
    } 
    registerAlias(alias, type);
  }

  //这就是注册别名的本质方法， 其实就是向保存别名的hashMap新增值而已， 呵呵， 别名的实现太简单了，对吧
  public void registerAlias(String alias, Class<?> value) {
    if (alias == null) throw new TypeException("The parameter alias cannot be null");
    String key = alias.toLowerCase(Locale.ENGLISH); // issue #748
    if (TYPE_ALIASES.containsKey(key) && TYPE_ALIASES.get(key) != null && !TYPE_ALIASES.get(key).equals(value)) {
      throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + TYPE_ALIASES.get(key).getName() + "'.");
    }
    TYPE_ALIASES.put(key, value);
  }
```

# 四、TypeHandler

> 实现Java类型跟数据库类型的相互转换。

```java
public interface TypeHandler<T> {  
   
	// 用于定义在Mybatis设置参数时该如何把Java类型的参数转换为对应的数据库类型 
    void setParameter(PreparedStatement ps, int i, T parameter,  
           JdbcType jdbcType) throws SQLException;  
   
    // 用于在Mybatis获取数据结果集时如何把数据库类型转换为对应的Java类型  
    T getResult(ResultSet rs, String columnName) throws SQLException;  
   
    // 用于在Mybatis通过字段位置获取字段数据时把数据库类型转换为对应的Java类型  
    T getResult(ResultSet rs, int columnIndex) throws SQLException;  
   
    // 用于Mybatis在调用存储过程后把数据库类型的数据转换为对应的Java类型   
    T getResult(CallableStatement cs, int columnIndex) throws SQLException;  
   
}  
```

## 4.1 自定义TypeHandler

User.String[]  <->  varchar 

### 4.1.1 实现typeHandler接口

```java
public class StringArrayTypeHandler implements TypeHandler<String[]> {  
   
       public String[] getResult(ResultSet rs, String columnName)  
                     throws SQLException {  
              String columnValue = rs.getString(columnName);  
              return this.getStringArray(columnValue);  
       }  
   
       public String[] getResult(ResultSet rs, int columnIndex)  
                     throws SQLException {  
              String columnValue = rs.getString(columnIndex);  
              return this.getStringArray(columnValue);  
       }  
   
       public String[] getResult(CallableStatement cs, int columnIndex)  
                     throws SQLException {  
              // TODO Auto-generated method stub  
              String columnValue = cs.getString(columnIndex);  
              return this.getStringArray(columnValue);  
       }  
   
       public void setParameter(PreparedStatement ps, int i, String[] parameter,  
                     JdbcType jdbcType) throws SQLException {  
              if (parameter == null)  
                     ps.setNull(i, Types.VARCHAR);  
              else {  
                     StringBuffer result = new StringBuffer();  
                     for (String value : parameter)  
                            result.append(value).append(",");  
                     result.deleteCharAt(result.length()-1);  
                     ps.setString(i, result.toString());  
              }  
       }  
   
       private String[] getStringArray(String columnValue) {  
              if (columnValue == null)  
                     return null;  
              return columnValue.split(",");  
       }  
   
}  
```

### 4.1.2 继承BaseTypeHandler

```java
public abstract class BaseTypeHandler<T> extends TypeReference<T> implements TypeHandler<T> {  
```

`BaseTypeHandler` 对 `TypeHandler` 接口的四个方法做了一个简单的选择，把null值的情况都做了一个过滤，核心的取值和设值的方法还是抽象出来了供子类来实现。

通过 `TypeReference.getRawType()` 可以获取到当前TypeHandler所使用泛型的原始类型

```java
public class StringArrayTypeHandler extends BaseTypeHandler<String[]> {  
   
    @Override  
    public String[] getNullableResult(ResultSet rs, String columnName)  
           throws SQLException {  
       return getStringArray(rs.getString(columnName));  
    }  
   
    @Override  
    public String[] getNullableResult(ResultSet rs, int columnIndex)  
           throws SQLException {  
       return this.getStringArray(rs.getString(columnIndex));  
    }  
   
    @Override  
    public String[] getNullableResult(CallableStatement cs, int columnIndex)  
           throws SQLException {  
       return this.getStringArray(cs.getString(columnIndex));  
    }  
   
    @Override  
    public void setNonNullParameter(PreparedStatement ps, int i,  
           String[] parameter, JdbcType jdbcType) throws SQLException {  
       //由于BaseTypeHandler中已经把parameter为null的情况做了处理，所以这里我们就不用再判断parameter是否为空了，直接用就可以了  
       StringBuffer result = new StringBuffer();  
       for (String value : parameter)  
           result.append(value).append(",");  
       result.deleteCharAt(result.length()-1);  
       ps.setString(i, result.toString());  
    }  
     
    private String[] getStringArray(String columnValue) {  
       if (columnValue == null)  
           return null;  
       return columnValue.split(",");  
    }  
}  
```

## 4.2 注册TypeHandler

<javaType, jdbcType>   →   TypeHandler

1. 指定 <javaType, jdbcType>   →   TypeHandler
2. 指定`javaType`
   - @MappedJdbcTypes({JdbcType.VARCHAR})        <javaType, jdbcType>   →   TypeHandler
   - 没有使用@MappedJdbcTypes                                 <javaType, null>   →   TypeHandler
3. (javaType==null && jdbcType==null)  || jdbcType != null
   - 使用@MappedTypes指定了javaType，goto【方式2】
   - `TypeHandler`没有使用@MappedTypes，但继承了``TypeReference`,使用`TypeReference.getRawType`获取javaType，goto【方式2】
   -  <null, null>   →   TypeHandler

## 4.3 Mybatis自动获取TypeHandler

UserMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper  
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
   
<mapper namespace="com.tiantian.mybatis.mapper.UserMapper">  
   
    <resultMap id="UserResult" type="User">  
       <id column="id" property="id"/>  
       <result column="interests" property="interests" javaType="[Ljava.lang.String;" jdbcType="VARCHAR"/>  
    </resultMap>  
   
    <insert id="insertUser" parameterType="User" useGeneratedKeys="true" keyColumn="id">  
       insert into t_user(name, age, interests) values(#{name}, #{age}, #{interests, javaType=[Ljava.lang.String;, jdbcType=VARCHAR})  
    </insert>  
     
    <update id="updateUser" parameterType="User">  
       update t_user set name=#{name}, age=#{age}, interests=#{interests} where id=#{id}  
    </update>  
     
    <select id="findById" parameterType="int" resultMap="UserResult">  
       select * from t_user where id=#{id}  
    </select>  
     
    <delete id="deleteUser" parameterType="int">  
       delete from t_user where id=#{id}  
    </delete>  
</mapper>  
```

1. 在resultMap中，指定了javaType和jdbcType去获取对应的TypeHandler
2. 只指定javaType，<javaType, null>  → TypeHandler

```xml
<result column="interests" property="interests" javaType="[Ljava.lang.String;"/> 
```

 	3. 只指定jdbcType，mybatis会根据`property`指定的java属性获取javaType，  <javaType, jdbcType>  → TypeHandler

```xml
<result column="interests" property="interests" jdbcType="VARCHAR"/> 
```

4. 直接使用typeHandler指定

```xml
 <result column="interests" property="interests" typeHandler="com.tiantian.mybatis.handler.StringArrayTypeHandler"/>  
```

# parser.parse()详解

[构建SqlSessionFactoryBuilder](# 一、SqlSessionFactoryBuilder) 

​		解析mybaits配置文件

​			 [解析<properties>](##2.3 propertiesElement 解析properties)

​			 [解析<environments>](##2.4 environmentsElement 解析environments)

​			 [解析<typeAliases>](##2.5 typeAliasesElement 自定义别名)

​			 [解析<typeHandler>](##2.6 typeHandlerElement )

​			 [解析<objectFactory>](##2.7 objectFactoryElement)

# mapper.xml文件详解

## 1. namespace

​	Mapper元素只有一个属性namespace，它有两个作用：

1. 区分不同的mapper
2. 与接口关联（**应用程序通过接口访问mybatis时，mybatis通过接口的完整名称查找对应的mapper配置**）。

```xml
<?xml version="1.0" encoding="UTF-8" ?>   
<!DOCTYPE mapper   
PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN"  
"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"> 

<!-- mapper 为根元素节点， 一个namespace对应一个dao -->
<mapper namespace="com.dy.dao.UserDao">

</mapper>
```

## 2. cache

> 配置本地命名空间的缓存。        

- `type` cache实现类，默认为PERPETUAL，可以使用自定义的cache实现类（别名或完整类名皆可）        
- `eviction` 回收算法，默认为LRU，可选的算法有：           
  - LRU– 最近最少使用的：移除最长时间不被使用的对象。            
  - FIFO– 先进先出：按对象进入缓存的顺序来移除它们。            
  - SOFT– 软引用：移除基于垃圾回收器状态和软引用规则的对象。           
  - WEAK– 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。        
- `flushInterval ` 刷新间隔，默认为1个小时，单位毫秒        
- `size` 缓存大小，默认大小1024，单位为引用数        
- `readOnly` 只读

```xml
<cache type="PERPETUAL" eviction="LRU" flushInterval="60000"  
        size="512" readOnly="true" />
```

## 3. cache-ref

> 从其他命名空间引用缓存配置。        

 每个cache都以namespace为id，所以cache-ref只需要配置一个namespace属性就可以了。

 需要注意的是，如果cache-ref和cache都配置了，以cache为准。  

```xml
<cache-ref namespace="com.someone.application.data.SomeMapper"/>
```

## 4. insert | update | delete

这里以insert举例

- `id` 对应dao里面的某个方法（相当于方法的实现），因此应该与方法名一致

- `parameterType` 

  将要传入语句的参数的完全限定类名或别名， 如果不配置，mybatis会通过ParameterHandler 根据参数类型默认选择合适的typeHandler进行处理 parameterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象）

- `flushCache` 任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）

- `statementType` 

  - PREPARED (默认)           ->  PreparedStatement
  - STATEMENT   ->  Statement
  - CALLABLE     ->  CallableStatement

- `keyProperty`

  仅对 insert 和 update 有用，默认unset

- `keyColumn` 仅对 insert 和 update 有用

- `useGeneratedKeys` 仅对 insert 和 update 有用 

  ​     MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键

- `timeout`  在抛出异常之前，驱动程序等待数据库返回请求结果的秒数

```xml
 <insert     
      id="insertUser"     
      parameterType="com.demo.User"
      flushCache="true"
      statementType="PREPARED"   
      keyProperty="" 
      keyColumn=""
      useGeneratedKeys="false"
      timeout="20">
     sql
</insert>
```

