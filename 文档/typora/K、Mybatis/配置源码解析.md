https://my.oschina.net/xianggao/blog/548896

四大Builder：

1. **XMLConfigBuilder**

   解析mybatis中configLocation属性中的全局xml文件，内部会使用 `XMLMapperBuilder` 解析各个xml文件。

2. **XMLMapperBuilder**

   遍历mybatis中mapperLocations属性中的xml文件中每个节点的Builder，比如user.xml，内部会使用 `XMLStatementBuilder` 处理xml中的每个节点。

3. **XMLStatementBuilder**

   解析xml文件中各个节点，比如select,insert,update,delete节点，内部会使用 `XMLScriptBuilder` 处理节点的sql部分，遍历产生的数据会丢到Configuration的mappedStatements中。

4. **XMLScriptBuilder**

   解析xml中各个节点sql部分的Builder。

```java
SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
```

# 一、SqlSessionFactoryBuilder

```java
public class SqlSessionFactoryBuilder {

    //Reader读取mybatis配置文件，传入构造方法
    //除了Reader外，其实还有对应的inputStream作为参数的构造方法，
    //这也体现了mybatis配置的灵活性
    public SqlSessionFactory build(Reader reader) {
        return build(reader, null, null);
    }

    public SqlSessionFactory build(Reader reader, String environment) {
        return build(reader, environment, null);
    }
  
    //mybatis配置文件 + properties, 此时mybatis配置文件中可以不配置properties，也能使用${}形式
    public SqlSessionFactory build(Reader reader, Properties properties) {
        return build(reader, null, properties);
    }
  
    //通过XMLConfigBuilder解析mybatis配置，然后创建SqlSessionFactory对象
    public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
        try {
            XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
            //下面看看这个方法的源码
            return build(parser.parse());
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error building SqlSession.", e);
        } finally {
            ErrorContext.instance().reset();
            try {
                reader.close();
            } catch (IOException e) {
                // Intentionally ignore. Prefer previous error.
            }
        }
    }
    
    public SqlSessionFactory build(Configuration config) {
        return new DefaultSqlSessionFactory(config);
    }
}
```



# 二、XMLConfigBuilder 解析配置文件

## 2.1 构造函数

```java
    public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {
        this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);
    }

    private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
        super(new Configuration());
        ErrorContext.instance().resource("SQL Mapper Configuration");
        this.configuration.setVariables(props); // 1.java初始化Builder传递的配置
        this.parsed = false;
        this.environment = environment;
        this.parser = parser;
    }
```

## 2.2 parse

```java
 //外部调用此方法对mybatis配置文件进行解析
    public Configuration parse() {
        if (parsed) {
            throw new BuilderException("Each XMLConfigBuilder can only be used once.");
        }
        parsed = true;
        //从根节点configuration
        parseConfiguration(parser.evalNode("/configuration"));
        return configuration;
    }

    //此方法就是解析configuration节点下的子节点
    //由此也可看出，我们在configuration下面能配置的节点为以下10个节点
    private void parseConfiguration(XNode root) {
        try {
            propertiesElement(root.evalNode("properties")); //issue #117 read properties first
            typeAliasesElement(root.evalNode("typeAliases"));
            pluginElement(root.evalNode("plugins"));
            objectFactoryElement(root.evalNode("objectFactory"));
            objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
            settingsElement(root.evalNode("settings"));
            environmentsElement(root.evalNode("environments"));
            databaseIdProviderElement(root.evalNode("databaseIdProvider"));
            typeHandlerElement(root.evalNode("typeHandlers"));
            mapperElement(root.evalNode("mappers"));
        } catch (Exception e) {
            throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
        }
    }
```

>1. configuration节点为根节点。
>
>2. 在configuration节点之下，我们可以配置10个子节点， 
>
>   分别为：properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers。

## 2.3 propertiesElement 解析properties

**配置**

```xml
    <!-- 方法一： 从外部指定properties配置文件, 除了使用resource属性指定外，还可通过url属性指定url  
        <properties resource="dbConfig.properties"></properties> 
    -->
    <!-- 方法二： 直接配置为xml -->
    <properties>
        <property name="driver" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/test1"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </properties>
```

​		[方法三](##2.1 构造函数)

三种方法的加载顺序：

			1. 方法三（java代码）初始化时加入configuration          this.configuration.setVariables(props);
   			2. 在下面代码先加载xml的配置到default                          Properties defaults = context.getChildrenAsProperties();
            			3. 加载外部指定配置文件（方法一）覆盖default             defaults.putAll(Resources.getUrlAsProperties(url));
                  			4. 把configuration覆盖加入default                                   defaults.putAll(vars);
            			5. configuration.setVariables(defaults);

  <strong style="color:red">**优先级：java代码Porperties对象 > 外部指定配置 >  xml配置**</strong>

```java
	private void propertiesElement(XNode context) throws Exception {
        if (context != null) {
            // 方法二
            Properties defaults = context.getChildrenAsProperties();
            // 获取properties节点上 resource属性的值
            String resource = context.getStringAttribute("resource");
            // 获取properties节点上 url属性的值, resource和url不能同时配置
            String url = context.getStringAttribute("url");
            if (resource != null && url != null) {
                throw new BuilderException("The properties element cannot specify both a URL and a resource based property file 					reference.  Please specify one or the other.");
            }
            // 把解析出的properties文件set进Properties对象
            if (resource != null) {
                defaults.putAll(Resources.getResourceAsProperties(resource));
            } else if (url != null) {
                defaults.putAll(Resources.getUrlAsProperties(url));
            }
            // 将configuration对象中已配置的Properties属性与刚刚解析的融合
            // configuration这个对象会装载所解析mybatis配置文件的所有节点元素，以后也会频频提到这个对象
            // 既然configuration对象用有一系列的get/set方法， 那是否就标志着我们可以使用java代码直接配置？ 
            // 答案是肯定的， 不过使用配置文件进行配置，优势不言而喻
            Properties vars = configuration.getVariables();  // 1. 得到构建sqlSessionFactoryBuilder传递的properties参数
            if (vars != null) {
                defaults.putAll(vars);
            }
            // 把装有解析配置propertis对象set进解析器， 因为后面可能会用到
            parser.setVariables(defaults);
            // set进configuration对象
            configuration.setVariables(defaults);
        }
    }
```

## 2.4 environmentsElement 解析environments

```xml
<environments default="development">
    <environment id="development">
        <!-- 
        JDBC–这个配置直接简单使用了JDBC的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。
        MANAGED–这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期（比如Spring或JEE应用服务器的上下文）。
        -->
        <transactionManager type="JDBC"/>
        <!--
        UNPOOLED–这个数据源的实现是每次被请求时简单打开和关闭连接
        POOLED–mybatis实现的简单的数据库连接池类型，它使得数据库连接可被复用，不必在每次请求时都去创建一个物理的连接。
        JNDI – 通过jndi从tomcat之类的容器里获取数据源。
        -->
        <dataSource type="POOLED">  
            <!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 -->
            <property name="driver" value="${driver}"/>
            <property name="url" value="${url}"/>
            <property name="username" value="${username}"/>
            <property name="password" value="${password}"/>  
        </dataSource>
    </environment>
    
    <!-- 我再指定一个environment -->
    <environment id="test">
        ...
    </environment>
</environments>
```

1. 根据default得到运行的环境
2. 配置事务  **mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务，配置为MANAGED则是将事务托管给容器，** 
3. 得到DataSource
4. 将environment配置加入configuration

```java
    private void environmentsElement(XNode context) throws Exception {
        if (context != null) {
            if (environment == null) {
                //解析environments节点的default属性的值
                //例如: <environments default="development">
                environment = context.getStringAttribute("default");
            }
            //递归解析environments子节点
            for (XNode child : context.getChildren()) { 
                String id = child.getStringAttribute("id");
                //isSpecial就是根据由environments的default属性去选择对应的enviroment
                if (isSpecifiedEnvironment(id)) {
                    //事务， mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务，配置为MANAGED则是将事务托管给容器， 
                    TransactionFactory txFactory = transactionManagerElement(child.evalNode("transactionManager"));
                    //enviroment节点下面就是dataSource节点了，解析dataSource节点（下面会贴出解析dataSource的具体方法）
                    DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource"));
                    DataSource dataSource = dsFactory.getDataSource();
                    Environment.Builder environmentBuilder = new Environment.Builder(id)
                          .transactionFactory(txFactory)
                          .dataSource(dataSource);
                    //老规矩，会将dataSource设置进configuration对象
                    configuration.setEnvironment(environmentBuilder.build());
                }
            }
        }
    }
```

### 2.4.1 dataSourceElement 解析dataSource

```java
    private DataSourceFactory dataSourceElement(XNode context) throws Exception {
        if (context != null) {
            //dataSource的连接池
            String type = context.getStringAttribute("type");
            //子节点 name, value属性set进一个properties对象
            Properties props = context.getChildrenAsProperties();
            //创建dataSourceFactory
            DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();
            factory.setProperties(props);
            return factory;
        }
        throw new BuilderException("Environment declaration requires a DataSourceFactory.");
    } 
```

## 2.5 typeAliasesElement 自定义别名

```xml
  	<typeAliases>
        <!--
        通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean,
        并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。
        也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) 
        <package name="com.dy.entity"/>
        -->
        <typeAlias alias="UserEntity" type="com.dy.entity.User"/>
    </typeAliases>
```



```java
private void typeAliasesElement(XNode parent) {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            //如果子节点是package, 那么就获取package节点的name属性， mybatis会扫描指定的package
            if ("package".equals(child.getName())) {
                String typeAliasPackage = child.getStringAttribute("name");
                //TypeAliasRegistry 负责管理别名， 这儿就是通过TypeAliasRegistry 进行别名注册， 下面就会看看TypeAliasRegistry源码
                configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
            } else {
                //如果子节点是typeAlias节点，那么就获取alias属性和type的属性值
                String alias = child.getStringAttribute("alias");
                String type = child.getStringAttribute("type");
                try {
                    Class<?> clazz = Resources.classForName(type);
                    if (alias == null) {
                        typeAliasRegistry.registerAlias(clazz);
                    } else {
                        typeAliasRegistry.registerAlias(alias, clazz);
                    }
                } catch (ClassNotFoundException e) {
                    throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
                }
            }
        }
    }
}
```

## 2.6 typeHandlerElement 

```xml
 <typeHandlers>
      <!-- 
          当配置package的时候，mybatis会去配置的package扫描TypeHandler
          <package name="com.dy.demo"/>
       -->
      <typeHandler javaType="" jdbcType="" handler=""/>
      
  </typeHandlers>
```

该方法就是通过解析javaType、jdbcType、TypeHandler放到typeHandlerRegistry的map中

```java
private void typeHandlerElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        //子节点为package时，获取其name属性的值，然后自动扫描package下的自定义typeHandler
        if ("package".equals(child.getName())) {
          String typeHandlerPackage = child.getStringAttribute("name");
          typeHandlerRegistry.register(typeHandlerPackage);
        } else {
          String javaTypeName = child.getStringAttribute("javaType");
          String jdbcTypeName = child.getStringAttribute("jdbcType");
          //handler就是我们配置的typeHandler
          String handlerTypeName = child.getStringAttribute("handler");
          //resolveClass方法就是我们上篇文章所讲的TypeAliasRegistry里面处理别名的方法
          Class<?> javaTypeClass = resolveClass(javaTypeName);
          //JdbcType是一个枚举类型，resolveJdbcType方法是在获取枚举类型的值
          JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
          Class<?> typeHandlerClass = resolveClass(handlerTypeName);
          //注册typeHandler, typeHandler通过TypeHandlerRegistry这个类管理
          if (javaTypeClass != null) {
            if (jdbcType == null) {
              typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);
            } else {
              typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);
            }
          } else {
            typeHandlerRegistry.register(typeHandlerClass);
          }
        }
      }
    }
}
```

## 2.7 objectFactoryElement

`MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成`。`默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化`。

自定义ObjectFactory

```xml
<objectFactory type="org.mybatis.example.ExampleObjectFactory">
        <property name="someProperty" value="100"/>
</objectFactory>
```

```java
private void objectFactoryElement(XNode context) throws Exception {
  if (context != null) {
    String type = context.getStringAttribute("type");
    Properties properties = context.getChildrenAsProperties();
    ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();
    factory.setProperties(properties);
    configuration.setObjectFactory(factory);
  }
}
```

## 2.8 pluginElement

plugins 是一个可选配置。`mybatis中的plugin其实就是个interceptor`， 它可以拦截Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler 的部分方法，处理我们自己的逻辑。

- `Executor` 就是真正执行sql语句的东西，
- ` ParameterHandler` 使用`TypeHandler`处理传入参数
- `ResultSetHandler` 就是处理返回结果的

```xml
    <plugins>
      <plugin interceptor="org.mybatis.example.ExamplePlugin">
        <property name="someProperty" value="100"/>
      </plugin>
    </plugins>
```



```java
  private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        String interceptor = child.getStringAttribute("interceptor");
        Properties properties = child.getChildrenAsProperties();
        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
        interceptorInstance.setProperties(properties);
        configuration.addInterceptor(interceptorInstance);
      }
    }
  }
```

## 2.9 mapperElement

```xml
    <mappers>
        <!-- 第一种方式：通过resource指定 -->
        <mapper resource="com/dy/dao/userDao.xml"/>
    
        <!-- 第二种方式， 通过class指定接口，进而将接口与对应的xml文件形成映射关系
             不过，使用这种方式必须保证 接口与mapper文件同名(不区分大小写)， 
             我这儿接口是UserDao,那么意味着mapper文件为UserDao.xml 
        <mapper class="com.dy.dao.UserDao"/>
        -->
      
        <!-- 第三种方式，直接指定包，自动扫描，与方法二同理 
        <package name="com.dy.dao"/>
        -->
        <!-- 第四种方式：通过url指定mapper文件位置
        <mapper url="file://........"/>
        -->
    </mappers>
```

`所谓的mapper映射文件，就是让mybatis 用来建立数据表和javabean映射的一个桥梁`。

在我们实际开发中，`通常一个mapper文件对应一个dao接口， 这个mapper可以看做是dao的实现`。所以,mappers必须配置。

## 2.10 settingsElement

```xml
<settings> 
    <setting name="cacheEnabled" value="true"/> 
    <setting name="lazyLoadingEnabled" value="true"/> 
    <setting name="multipleResultSetsEnabled" value="true"/> 
    <setting name="useColumnLabel" value="true"/> 
    <setting name="useGeneratedKeys" value="false"/> 
    <setting name="enhancementEnabled" value="false"/> 
    <setting name="defaultExecutorType" value="SIMPLE"/> 
    <setting name="defaultStatementTimeout" value="25000"/> 
</settings>
```

setting节点里配置的值会直接改写Configuration对应的变量值，这些变量描述的是Mybatis的全局运行方式

```java
  private void settingsElement(Properties props) throws Exception {
    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty("autoMappingBehavior", "PARTIAL")));
    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty("autoMappingUnknownColumnBehavior", "NONE")));
    configuration.setCacheEnabled(booleanValueOf(props.getProperty("cacheEnabled"), true));
    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty("proxyFactory")));
	...
  }
```

<img src="D:\myself\springboot-example\文档\typora\images\mybatis01.png" alt="è¾å¥å¾çè¯´æ" style="zoom:50%;" />

# 三、**TypeAliasRegistry** 

## 3.1 成员变量 TYPE_ALIASES 

```java
  //这就是核心所在啊， 原来别名就仅仅通过一个HashMap来实现， key为别名， value就是别名对应的类型（class对象）
  private final Map<String, Class<?>> TYPE_ALIASES = new HashMap<String, Class<?>>();
```

## 3.2 构造器

```java
  /**
   * 以下就是mybatis默认为我们注册的别名
   */
  public TypeAliasRegistry() {
    registerAlias("string", String.class);

    registerAlias("byte", Byte.class);
    registerAlias("long", Long.class);
    registerAlias("short", Short.class);
    registerAlias("int", Integer.class);
    registerAlias("integer", Integer.class);
    registerAlias("double", Double.class);
    registerAlias("float", Float.class);
    registerAlias("boolean", Boolean.class);
    ....
  }
```

## 3.3 registerAliases(String packageName)

```java
  /**
   * 配置文件中配置为package的时候， 会调用此方法，根据配置的报名去扫描javabean ，然后自动注册别名
   * 默认会使用 Bean 的首字母小写的非限定类名来作为它的别名
   * 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user)
   */
  public void registerAliases(String packageName){
    registerAliases(packageName, Object.class);
  }

  public void registerAliases(String packageName, Class<?> superType){
    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<Class<?>>();
    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
    Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();
    for(Class<?> type : typeSet){
      // Ignore inner classes and interfaces (including package-info.java)
      // Skip also inner classes. See issue #6
      if (!type.isAnonymousClass() && !type.isInterface() && !type.isMemberClass()) {
        registerAlias(type);
      }
    }
  }
```

## 3.4 registerAlias

```java
  public void registerAlias(Class<?> type) {
    String alias = type.getSimpleName();
    Alias aliasAnnotation = type.getAnnotation(Alias.class);
    if (aliasAnnotation != null) {
      alias = aliasAnnotation.value();
    } 
    registerAlias(alias, type);
  }

  //这就是注册别名的本质方法， 其实就是向保存别名的hashMap新增值而已， 呵呵， 别名的实现太简单了，对吧
  public void registerAlias(String alias, Class<?> value) {
    if (alias == null) throw new TypeException("The parameter alias cannot be null");
    String key = alias.toLowerCase(Locale.ENGLISH); // issue #748
    if (TYPE_ALIASES.containsKey(key) && TYPE_ALIASES.get(key) != null && !TYPE_ALIASES.get(key).equals(value)) {
      throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + TYPE_ALIASES.get(key).getName() + "'.");
    }
    TYPE_ALIASES.put(key, value);
  }
```

# 四、TypeHandler

> 实现Java类型跟数据库类型的相互转换。

```java
public interface TypeHandler<T> {  
   
	// 用于定义在Mybatis设置参数时该如何把Java类型的参数转换为对应的数据库类型 
    void setParameter(PreparedStatement ps, int i, T parameter,  
           JdbcType jdbcType) throws SQLException;  
   
    // 用于在Mybatis获取数据结果集时如何把数据库类型转换为对应的Java类型  
    T getResult(ResultSet rs, String columnName) throws SQLException;  
   
    // 用于在Mybatis通过字段位置获取字段数据时把数据库类型转换为对应的Java类型  
    T getResult(ResultSet rs, int columnIndex) throws SQLException;  
   
    // 用于Mybatis在调用存储过程后把数据库类型的数据转换为对应的Java类型   
    T getResult(CallableStatement cs, int columnIndex) throws SQLException;  
   
}  
```

## 4.1 自定义TypeHandler

User.String[]  <->  varchar 

### 4.1.1 实现typeHandler接口

```java
public class StringArrayTypeHandler implements TypeHandler<String[]> {  
   
       public String[] getResult(ResultSet rs, String columnName)  
                     throws SQLException {  
              String columnValue = rs.getString(columnName);  
              return this.getStringArray(columnValue);  
       }  
   
       public String[] getResult(ResultSet rs, int columnIndex)  
                     throws SQLException {  
              String columnValue = rs.getString(columnIndex);  
              return this.getStringArray(columnValue);  
       }  
   
       public String[] getResult(CallableStatement cs, int columnIndex)  
                     throws SQLException {  
              // TODO Auto-generated method stub  
              String columnValue = cs.getString(columnIndex);  
              return this.getStringArray(columnValue);  
       }  
   
       public void setParameter(PreparedStatement ps, int i, String[] parameter,  
                     JdbcType jdbcType) throws SQLException {  
              if (parameter == null)  
                     ps.setNull(i, Types.VARCHAR);  
              else {  
                     StringBuffer result = new StringBuffer();  
                     for (String value : parameter)  
                            result.append(value).append(",");  
                     result.deleteCharAt(result.length()-1);  
                     ps.setString(i, result.toString());  
              }  
       }  
   
       private String[] getStringArray(String columnValue) {  
              if (columnValue == null)  
                     return null;  
              return columnValue.split(",");  
       }  
   
}  
```

### 4.1.2 继承BaseTypeHandler

```java
public abstract class BaseTypeHandler<T> extends TypeReference<T> implements TypeHandler<T> {  
```

`BaseTypeHandler` 对 `TypeHandler` 接口的四个方法做了一个简单的选择，把null值的情况都做了一个过滤，核心的取值和设值的方法还是抽象出来了供子类来实现。

通过 `TypeReference.getRawType()` 可以获取到当前TypeHandler所使用泛型的原始类型

```java
public class StringArrayTypeHandler extends BaseTypeHandler<String[]> {  
   
    @Override  
    public String[] getNullableResult(ResultSet rs, String columnName)  
           throws SQLException {  
       return getStringArray(rs.getString(columnName));  
    }  
   
    @Override  
    public String[] getNullableResult(ResultSet rs, int columnIndex)  
           throws SQLException {  
       return this.getStringArray(rs.getString(columnIndex));  
    }  
   
    @Override  
    public String[] getNullableResult(CallableStatement cs, int columnIndex)  
           throws SQLException {  
       return this.getStringArray(cs.getString(columnIndex));  
    }  
   
    @Override  
    public void setNonNullParameter(PreparedStatement ps, int i,  
           String[] parameter, JdbcType jdbcType) throws SQLException {  
       //由于BaseTypeHandler中已经把parameter为null的情况做了处理，所以这里我们就不用再判断parameter是否为空了，直接用就可以了  
       StringBuffer result = new StringBuffer();  
       for (String value : parameter)  
           result.append(value).append(",");  
       result.deleteCharAt(result.length()-1);  
       ps.setString(i, result.toString());  
    }  
     
    private String[] getStringArray(String columnValue) {  
       if (columnValue == null)  
           return null;  
       return columnValue.split(",");  
    }  
}  
```

## 4.2 注册TypeHandler

<javaType, jdbcType>   →   TypeHandler

1. 指定 <javaType, jdbcType>   →   TypeHandler
2. 指定`javaType`
   - @MappedJdbcTypes({JdbcType.VARCHAR})        <javaType, jdbcType>   →   TypeHandler
   - 没有使用@MappedJdbcTypes                                 <javaType, null>   →   TypeHandler
3. (javaType==null && jdbcType==null)  || jdbcType != null
   - 使用@MappedTypes指定了javaType，goto【方式2】
   - `TypeHandler`没有使用@MappedTypes，但继承了``TypeReference`,使用`TypeReference.getRawType`获取javaType，goto【方式2】
   -  <null, null>   →   TypeHandler

## 4.3 Mybatis自动获取TypeHandler

UserMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper  
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
   
<mapper namespace="com.tiantian.mybatis.mapper.UserMapper">  
   
    <resultMap id="UserResult" type="User">  
       <id column="id" property="id"/>  
       <result column="interests" property="interests" javaType="[Ljava.lang.String;" jdbcType="VARCHAR"/>  
    </resultMap>  
   
    <insert id="insertUser" parameterType="User" useGeneratedKeys="true" keyColumn="id">  
       insert into t_user(name, age, interests) values(#{name}, #{age}, #{interests, javaType=[Ljava.lang.String;, jdbcType=VARCHAR})  
    </insert>  
     
    <update id="updateUser" parameterType="User">  
       update t_user set name=#{name}, age=#{age}, interests=#{interests} where id=#{id}  
    </update>  
     
    <select id="findById" parameterType="int" resultMap="UserResult">  
       select * from t_user where id=#{id}  
    </select>  
     
    <delete id="deleteUser" parameterType="int">  
       delete from t_user where id=#{id}  
    </delete>  
</mapper>  
```

1. 在resultMap中，指定了javaType和jdbcType去获取对应的TypeHandler
2. 只指定javaType，<javaType, null>  → TypeHandler

```xml
<result column="interests" property="interests" javaType="[Ljava.lang.String;"/> 
```

 	3. 只指定jdbcType，mybatis会根据`property`指定的java属性获取javaType，  <javaType, jdbcType>  → TypeHandler

```xml
<result column="interests" property="interests" jdbcType="VARCHAR"/> 
```

4. 直接使用typeHandler指定

```xml
 <result column="interests" property="interests" typeHandler="com.tiantian.mybatis.handler.StringArrayTypeHandler"/>  
```

# 五、XMLMapperBuilder

Mapper配置文件是由XMLMapperBuilder解析的

- cacheElement
- cacheRefElement
- resultMapElement
- sqlElement

# parser.parse()详解

[构建SqlSessionFactoryBuilder](# 一、SqlSessionFactoryBuilder) 

​		解析mybaits配置文件

​			 [解析<properties>](##2.3 propertiesElement 解析properties)

​			 [解析<environments>](##2.4 environmentsElement 解析environments)

​			 [解析<typeAliases>](##2.5 typeAliasesElement 自定义别名)

​			 [解析<typeHandler>](##2.6 typeHandlerElement )

​			 [解析<objectFactory>](##2.7 objectFactoryElement)

​			 解析<mappers>

# mapper.xml文件详解

## 1. namespace

​	Mapper元素只有一个属性namespace，它有两个作用：

1. 区分不同的mapper
2. 与接口关联（**应用程序通过接口访问mybatis时，mybatis通过接口的完整名称查找对应的mapper配置**）。

```xml
<?xml version="1.0" encoding="UTF-8" ?>   
<!DOCTYPE mapper   
PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN"  
"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"> 

<!-- mapper 为根元素节点， 一个namespace对应一个dao -->
<mapper namespace="com.dy.dao.UserDao">

</mapper>
```

## 2. cache

> 配置本地命名空间的缓存。        

- `type` cache实现类，默认为PERPETUAL，可以使用自定义的cache实现类（别名或完整类名皆可）        
- `eviction` 回收算法，默认为LRU，可选的算法有：           
  - LRU– 最近最少使用的：移除最长时间不被使用的对象。            
  - FIFO– 先进先出：按对象进入缓存的顺序来移除它们。            
  - SOFT– 软引用：移除基于垃圾回收器状态和软引用规则的对象。           
  - WEAK– 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。        
- `flushInterval ` 刷新间隔，默认为1个小时，单位毫秒        
- `size` 缓存大小，默认大小1024，单位为引用数        
- `readOnly` 只读

```xml
<cache type="PERPETUAL" eviction="LRU" flushInterval="60000"  
        size="512" readOnly="true" />
```

## 3. cache-ref

> 从其他命名空间引用缓存配置。        

 每个cache都以namespace为id，所以cache-ref只需要配置一个namespace属性就可以了。

 需要注意的是，如果cache-ref和cache都配置了，以cache为准。  

```xml
<cache-ref namespace="com.someone.application.data.SomeMapper"/>
```

## 4. insert | update | delete

这里以insert举例

- `id` 对应dao里面的某个方法（相当于方法的实现），因此应该与方法名一致

- `parameterType` 

  将要传入语句的参数的完全限定类名或别名， 如果不配置，mybatis会通过ParameterHandler 根据参数类型默认选择合适的typeHandler进行处理 parameterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象）

- `flushCache` 任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）

- `statementType` 

  - PREPARED (默认)           ->  PreparedStatement
  - STATEMENT   ->  Statement
  - CALLABLE     ->  CallableStatement

- `keyProperty`

  仅对 insert 和 update 有用，默认unset

- `keyColumn` 仅对 insert 和 update 有用

- `useGeneratedKeys` 仅对 insert 和 update 有用 

  ​     MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键

- `timeout`  在抛出异常之前，驱动程序等待数据库返回请求结果的秒数

```xml
 <insert     
      id="insertUser"     
      parameterType="com.demo.User"
      flushCache="true"
      statementType="PREPARED"   
      keyProperty="" 
      keyColumn=""
      useGeneratedKeys="false"
      timeout="20">
     sql
</insert>
```

### 4.1 selectKey

```xml
<selectKey
        <!-- selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 -->
        keyProperty="id"
        <!-- 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。 -->
        resultType="int"
        <!-- 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。 -->
        order="BEFORE"
        <!-- 与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。 -->
        statementType="PREPARED">
```

example

```xml
<insert id="insertUser" parameterType="com.dy.entity.User">
        <!-- oracle等不支持id自增长的，可根据其id生成策略，先获取id 
        <selectKey resultType="int" order="BEFORE" keyProperty="id">
              select seq_user_id.nextval as id from dual
        </selectKey>
        --> 
        
        <!-- mysql插入数据后，获取id，该方法LAST_INSERT_ID()与数据库连接绑定，同属统一会话级别。-->
        <selectKey keyProperty="id" resultType="int" order="AFTER" >
               SELECT LAST_INSERT_ID() as id
        </selectKey>
          
        insert into user(id, name, password, age, deleteFlag) 
        values(#{id}, #{name}, #{password}, #{age}, #{deleteFlag})
   </insert>
```

## 5. resultMap配置一对一、一对多、多对对关系

一对多

```xml
<!-- 
      property 为javabean中容器对应字段名
      column 为体现在数据库中列名
      ofType 就是指定javabean中容器指定的类型

      不同情况需要告诉MyBatis 如何加载一个聚集。MyBatis 可以用两种方式加载：
         1. select: 执行一个其它映射的SQL 语句返回一个Java实体类型。较灵活；
         2. resultMap: 使用一个嵌套的结果映射来处理通过join查询结果集，映射成Java实体类型。
-->
<collection property="" column="" ofType=""></collection>
```

一对一

```xml
 <association property="" column="" javaType=""></association>
```

example

```xml
<!--
     方式一：嵌套结果：使用嵌套结果映射来处理重复的联合结果的子集
             封装联表查询的数据(去除重复的数据)
     select * from classes c, teacher t where c.tid=t.tid and c.tid=#{tid}
 -->
<select id="getClasses" resultMap="getClassesMap" parameterType="int">
    select * from classes c ,teacher t
        where c.tid=t.tid and c.tid=#{tid}
</select>
<resultMap type="com.zzc.entity.Classes" id="getClassesMap">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <association property="teacher" javaType="com.zzc.entity.Teacher">
        <id column="tid" property="tid"></id>
        <result column="tname" property="tname"/>
    </association>
</resultMap>

<!--
     方式二：嵌套查询：通过执行另外一个SQL映射语句来返回预期的复杂类型
     SELECT * FROM classes WHERE cid=1;
     SELECT * FROM teacher WHERE tid=1   //1 是上一个查询得到的tid的值
     property:别名(属性名)    column：列名 -->
<!-- 把teacher的字段设置进去 -->
<select id="getClasses2" resultMap="getClassesMap2">
    select * from classes c where c.cid = #{cid}
</select>
<resultMap type="com.zzc.entity.Classes" id="getClassesMap2">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="teacher" column="tid" select="getTeacherCollection">
    </collection>
</resultMap>
<select id="getTeacherCollection" resultType="com.zzc.entity.Teacher">
    select tid tid,tname tname from teacher where tid=#{tid}
</select>
```

# 动态SQL

```xml
<if test="id != null">
     id=#{id}
</if>

<where>
    <if test="id != null">
         id=#{id}
    </if> 
    and deleteFlag=0;
</where>

<!-- 当WHERE后紧随AND或则OR的时候，就去除AND或者O -->
<trim prefix="WHERE" prefixOverrides="AND |OR ">
    ... 
</trim>

<!-- set最后去除逗号 -->
<set>
      <if test="name != null">name = #{name},</if> 
      <if test="password != null">password = #{password},</if> 
      <if test="age != null">age = #{age},</if> 
</set>

<foreach item="item" index="index" collection="list"
    open="(" separator="," close=")">
    #{item}
</foreach>

<choose>
        <when test="title != null">
            AND title like #{title}
        </when>
        <when test="author != null and author.name != null">
            AND author_name like #{author.name}
        </when>
        <otherwise>
            AND featured = 1
        </otherwise>
</choose>
```

## 1. 关于动态SQL的接口和类

### 1.1 SqlNode

   xml中的每个标签，比如上述sql的update,trim,if标签：

<img src="D:\myself\springboot-example\文档\typora\images\mybatis02.png" alt="è¾å¥å¾çè¯´æ" style="zoom: 50%;" />

### 1.2 SqlSource

​	代表从xml文件或注解映射的sql内容，主要就是用于创建BoundSql

​	`BoundSql类`，封装mybatis最终产生sql的类，包括sql语句，参数，参数源数据等参数

![è¾å¥å¾çè¯´æ](D:\myself\springboot-example\文档\typora\images\mybatis03.png)

## 2. 解析动态sql过程

1. XMLConfigBuilder解析mapper.xml

   ```java
   mapperElement(root.evalNode("mappers"));
   
   // mapperElement方法
   XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
   mapperParser.parse();
   ```

2. XMLMapperBuilder 解析<mapper>

   ```java
   public void parse() {
   	...
       configurationElement(parser.evalNode("/mapper"));
       ...
   }
   
     private void configurationElement(XNode context) {
       try {
         String namespace = context.getStringAttribute("namespace");
         if (namespace == null || namespace.equals("")) {
           throw new BuilderException("Mapper's namespace cannot be empty");
         }
         builderAssistant.setCurrentNamespace(namespace);
         cacheRefElement(context.evalNode("cache-ref"));
         cacheElement(context.evalNode("cache"));
         parameterMapElement(context.evalNodes("/mapper/parameterMap"));
         resultMapElements(context.evalNodes("/mapper/resultMap"));
         sqlElement(context.evalNodes("/mapper/sql"));
         //解析动态sql
         buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
       } catch (Exception e) {
         throw new BuilderException("Error parsing Mapper XML. Cause: " + e, e);
       }
     }
   
     private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {
       for (XNode context : list) {
           // 使用XMLStatementBuilder
         final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
         try {
           statementParser.parseStatementNode();
         } catch (IncompleteElementException e) {
           configuration.addIncompleteStatement(statementParser);
         }
       }
     }
   ```

3. XMLStatementBuilder 解析每个节点CRUD

   ```java
   public void parseStatementNode() {
       ...
   	LanguageDriver langDriver = this.getLanguageDriver(lang);
       ...
   	SqlSource sqlSource = langDriver.createSqlSource(this.configuration, this.context, parameterTypeClass);
       ...
   }
   ```

4. LanguageDriver解析SQL，得到SqlSource

   ```java
   @Override
   public SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType) {
     XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);
     return builder.parseScriptNode();
   }
   ```

5. XMLScriptBuilder 解析SQL

   > 得到SqlSource之后，会放到Configuration中，有了SqlSource，就能拿BoundSql了，BoundSql可以得到最终的sql。

   ```java
   public SqlSource parseScriptNode() {
       List<SqlNode> contents = this.parseDynamicTags(this.context);
       MixedSqlNode rootSqlNode = new MixedSqlNode(contents);
       SqlSource sqlSource = null;
       if (this.isDynamic) {
           sqlSource = new DynamicSqlSource(this.configuration, rootSqlNode);
       } else {
           sqlSource = new RawSqlSource(this.configuration, rootSqlNode, this.parameterType);
       }
   
       return (SqlSource)sqlSource;
   }
   ```

## 3. parseDynamicTags

```xml
<update id="update" parameterType="org.format.dynamicproxy.mybatis.bean.User">
    UPDATE users
    <trim prefix="SET" prefixOverrides=",">
        <if test="name != null and name != ''">
            name = #{name}
        </if>
        <if test="age != null and age != ''">
            , age = #{age}
        </if>
        <if test="birthday != null and birthday != ''">
            , birthday = #{birthday}
        </if>
    </trim>
    where id = ${id}
</update>
```

1. 首先根据update节点(Node)得到所有的子节点，分别是3个子节点：
   - 文本节点 \n UPDATE users
   - trim子节点 ...
   - 文本节点 \n where id = #{id}

2. 遍历各个子节点：

   2.1 `如果节点类型是文本或者CDATA`，构造一个TextSqlNode或StaticTextSqlNode；

   2.2 `如果节点类型是元素，说明该update节点是个动态sql`，然后会使用NodeHandler处理各个类型的子节点。这里的NodeHandler是XMLScriptBuilder的一个内部接口，其实现类包括TrimHandler、WhereHandler、SetHandler、IfHandler、ChooseHandler等。看类名也就明白了这个Handler的作用，比如我们分析的trim节点，对应的是TrimHandler；if节点，对应的是IfHandler...这里子节点trim被TrimHandler处理，TrimHandler内部也使用parseDynamicTags方法解析节点。

3. 遇到子节点是元素的话，重复以上步骤

# 通过JDK动态代理来包装SqlSession 源码分析

https://blog.csdn.net/zcw4237256/article/details/79032351

# SQL执行流程

```java
SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
SqlSession sqlSession = sessionFactory.openSession();
// 使用sqlSession执行sql
ObjectMapper mapper = sqlSession.getMapper("");
```

## 1. 通过XMLConfigBuilder解析配置文件

## 2. 创建SqlSession

```java
 private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
   Transaction tx = null;
   try {
     //通过Confuguration对象去获取Mybatis相关配置信息, Environment对象包含了数据源和事务的配置
     final Environment environment = configuration.getEnvironment();
     final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
     tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
     //之前说了，从表面上来看，咱们是用sqlSession在执行sql语句， 实际呢，其实是通过excutor执行， excutor是对于Statement的封装
     final Executor executor = configuration.newExecutor(tx, execType);
     //关键看这儿，创建了一个DefaultSqlSession对象
     return new DefaultSqlSession(configuration, executor, autoCommit);
   } catch (Exception e) {
     closeTransaction(tx); // may have fetched a connection so lets call close()
     throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);
   } finally {
     ErrorContext.instance().reset();
   }
 }
```

1. 从配置中获取Environment；
2. 从Environment中取得DataSource；
3. 从Environment中取得TransactionFactory；
4. 从DataSource里获取数据库连接对象Connection；
5. 在取得的数据库连接上创建事务对象Transaction；
6. 创建Executor对象（该对象非常重要，事实上sqlsession的所有操作都是通过它完成的）；
7. 创建sqlsession对象。

## 3. jdk动态代理获取mapper代理对象MapperProxy

## 4. 执行sql

### 4.1 MapperProxy.invoke ->

```java
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (Object.class.equals(method.getDeclaringClass())) {
      try {
        return method.invoke(this, args);
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    //二话不说，主要交给MapperMethod自己去管
    return mapperMethod.execute(sqlSession, args);
  }
```

### 4.2 mapperMethod.execute ->

```java
  /**
   * 其实就是先判断CRUD类型，然后根据类型去选择到底执行sqlSession中的哪个方法，
   */
  public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    if (SqlCommandType.INSERT == command.getType()) {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
    } 
    ...
    return result;
  }
```

### 4.3 sqlSession.selectList ->

```java
  public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      MappedStatement ms = configuration.getMappedStatement(statement);
      //CRUD实际上是交给Excetor去处理， excutor其实也只是穿了个马甲而已，小样，别以为穿个马甲我就不认识你嘞！
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
```

### 4.4 Excutor.query

#### 4.4.1 Excutor实例化

**Sqlsession只是个门面，真正干事的是Executor，Sqlsession对数据库的操作都是通过Executor来完成的**

`Executor对象是可以被插件拦截的，如果定义了针对Executor类型的插件，最终生成的Executor对象是被各个插件插入后的代理对象`。

```java
    public Executor newExecutor(Transaction transaction, ExecutorType executorType) {  
  
        executorType = executorType == null ? defaultExecutorType : executorType;  
  
        executorType = executorType == null ?ExecutorType.SIMPLE : executorType;  
  
        Executor executor;  
  
        if(ExecutorType.BATCH == executorType) {
            executor = new BatchExecutor(this,transaction);
        } else if(ExecutorType.REUSE == executorType) {
            executor = new ReuseExecutor(this,transaction);  
        } else {  
            executor = newSimpleExecutor(this, transaction);
        }
  
        if (cacheEnabled) {
           executor = new CachingExecutor(executor);  
        }
        executor = (Executor) interceptorChain.pluginAll(executor);  
        return executor;  
    }  
```

- `BatchExecutor  `专门用于执行批量sql操作
- `ReuseExecutor` 会重用statement执行sql操作
- `SimpleExecutor` 只是简单执行sql没有什么特别的，**默认**

>`CachingExecutor` 在查询数据库前先查找缓存，若没找到的话调用delegate（就是构造时传入的Executor对象）从数据库查询，并将查询结果存入缓存中
>
>**默认开启缓存**

#### 4.4.2 query

```java
public List query(MappedStatement ms, Object parameterObject, RowBounds rowBounds,ResultHandler resultHandler) throws SQLException {  
    if (ms != null) {  
        Cache cache = ms.getCache();  
        if (cache != null) {  
            flushCacheIfRequired(ms);  
            cache.getReadWriteLock().readLock().lock();  
            try {  
                if (ms.isUseCache() && resultHandler ==null) {  
                    CacheKey key = createCacheKey(ms, parameterObject, rowBounds);  
                    final List cachedList = (List)cache.getObject(key);  
                    if (cachedList != null) {  
                        return cachedList;  
                    } else {  
                        List list = delegate.query(ms,parameterObject, rowBounds, resultHandler);  
                        tcm.putObject(cache,key, list);  
                        return list;  
                    }  
                } else {  
                    return delegate.query(ms,parameterObject, rowBounds, resultHandler);  
                }  
            } finally {  
                cache.getReadWriteLock().readLock().unlock();  
            }
        }  
    }  
    return delegate.query(ms,parameterObject, rowBounds, resultHandler);  
}
```

最终调用到StatementHandler处理sql

```java
  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      stmt = prepareStatement(handler, ms.getStatementLog());
      //StatementHandler封装了Statement, 让 StatementHandler 去处理
      return handler.<E>query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
```

# 插件原理

MyBatis提供了一种插件(plugin)的功能，虽然叫做插件，但其实这是拦截器功能。

**MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用**。

1. Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) 拦截执行器的方法

2. ParameterHandler (getParameterObject, setParameters) 拦截参数的处理

3. ResultSetHandler (handleResultSets, handleOutputParameters) 拦截结果集的处理

4. StatementHandler (prepare, parameterize, batch, update, query) 拦截Sql语法构建的处理

   

Mybatis采用**责任链模式**，通过**动态代理**组织多个拦截器（插件），通过这些拦截器可以改变Mybatis的默认行为（诸如SQL重写之类的），



**在编写插件时需注意以下几个原则：**

1. 不编写不必要的插件；
2. 实现plugin方法时判断一下目标类型，是本插件要拦截的对象才执行Plugin.wrap方法，否者直接返回目标本省，这样可以减少目标被代理的次数。

## 1. 拦截器的使用

- intercept

  `实现拦截逻辑的地方`，`内部要通过invocation.proceed()显式地推进责任链前进`，也就是调用下一个拦截器拦截目标方法

- plugin

  `用当前这个拦截器生成对目标target的代理`，实际是通过Plugin.wrap(target,this)来完成的，把目标target和拦截器this传给了包装函数。

- setProperties

  设置额外的参数`，参数配置在`拦截器的Properties节点里

**定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，**

​	**在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。**

​	**而intercept方法就是要进行拦截的时候要执行的方法。**

```java
public interface Interceptor {

  Object intercept(Invocation invocation) throws Throwable;

  Object plugin(Object target);

  void setProperties(Properties properties);

}
```

实现：

```java
@Intercepts({@Signature(type= Executor.class, method = "update", args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  public Object intercept(Invocation invocation) throws Throwable {
    return invocation.proceed();
  }
  public Object plugin(Object target) {
    return Plugin.wrap(target, this);
  }
  public void setProperties(Properties properties) {
  }
}
```

```xml
<plugins>
    <plugin interceptor="org.format.mybatis.cache.interceptor.ExamplePlugin"></plugin>
</plugins>
```

**Plugin.wrap**

决定要返回的对象是目标对象还是对应的代理

```java
 //一个静态方法,对一个目标对象进行包装，生成代理类。
  public static Object wrap(Object target, Interceptor interceptor) {
    //首先根据interceptor上面定义的注解 获取需要拦截的信息
    Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);
    //目标对象的Class
    Class<?> type = target.getClass();
    //返回需要拦截的接口信息
    Class<?>[] interfaces = getAllInterfaces(type, signatureMap);
    //如果长度为>0 则返回代理类 否则不做处理
    if (interfaces.length > 0) {
      return Proxy.newProxyInstance(
          type.getClassLoader(),
          interfaces,
          new Plugin(target, interceptor, signatureMap));
    }
    return target;
  }
```



## 2. 加入拦截器链

```java
private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            String interceptor = child.getStringAttribute("interceptor");
            Properties properties = child.getChildrenAsProperties();
            Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
            interceptorInstance.setProperties(properties);
            configuration.addInterceptor(interceptorInstance);
        }
    }
}

public void addInterceptor(Interceptor interceptor) {
    interceptorChain.addInterceptor(interceptor);
}
```

`interceptorChain `是 `Configuration` 的内部属性

```java
public class InterceptorChain {

    private final List<Interceptor> interceptors = new ArrayList<Interceptor>();

    public Object pluginAll(Object target) {
        for (Interceptor interceptor : interceptors) {
            target = interceptor.plugin(target);
        }
        return target;
    }

    public void addInterceptor(Interceptor interceptor) {
        interceptors.add(interceptor);
    }

    public List<Interceptor> getInterceptors() {
        return Collections.unmodifiableList(interceptors);
    }

}
```

## 3. 拦截器如何作用

```java
public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
    return parameterHandler;
}

public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) {
    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
    return resultSetHandler;
}

public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
    return statementHandler;
}

public Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) {
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    Executor executor;
    if (ExecutorType.BATCH == executorType) {
        executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
        executor = new ReuseExecutor(this, transaction);
    } else {
        executor = new SimpleExecutor(this, transaction);
    }
    if (cacheEnabled) {
        executor = new CachingExecutor(executor, autoCommit);
    }
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
}
```

## 4. 自定义分页插件

https://my.oschina.net/xianggao/blog/550537

Mybatis的分页功能很弱，它是基于内存的分页（`查出所有记录再按偏移量和limit取结果`），`在大数据量的情况下这样的分页基本上是没有用的`。

本文基于插件，通过拦截StatementHandler重写sql语句，`实现数据库的物理分页`。

```java
public Object intercept(Invocation invocation) throws Throwable {  
     StatementHandler statementHandler = (StatementHandler) invocation.getTarget();  
     MetaObject metaStatementHandler = MetaObject.forObject(statementHandler,  
     DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY);  
     // 分离代理对象链(由于目标类可能被多个拦截器拦截，从而形成多次代理，通过下面的两次循环  
     // 可以分离出最原始的的目标类)  
     while (metaStatementHandler.hasGetter("h")) {  
         Object object = metaStatementHandler.getValue("h");  
         metaStatementHandler = MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY,   
         DEFAULT_OBJECT_WRAPPER_FACTORY);  
     }  
     // 分离最后一个代理对象的目标类  
     while (metaStatementHandler.hasGetter("target")) {  
         Object object = metaStatementHandler.getValue("target");  
         metaStatementHandler = MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY,   
         DEFAULT_OBJECT_WRAPPER_FACTORY);  
     }  
     Configuration configuration = (Configuration) metaStatementHandler.  
     getValue("delegate.configuration");  
     dialect = configuration.getVariables().getProperty("dialect");  
     if (null == dialect || "".equals(dialect)) {  
         logger.warn("Property dialect is not setted,use default 'mysql' ");  
         dialect = defaultDialect;  
     }  
     pageSqlId = configuration.getVariables().getProperty("pageSqlId");  
     if (null == pageSqlId || "".equals(pageSqlId)) {  
         logger.warn("Property pageSqlId is not setted,use default '.*Page$' ");  
         pageSqlId = defaultPageSqlId;  
     }  
     MappedStatement mappedStatement = (MappedStatement)   
     metaStatementHandler.getValue("delegate.mappedStatement");  
     // 只重写需要分页的sql语句。通过MappedStatement的ID匹配，默认重写以Page结尾的  
     //  MappedStatement的sql  
     if (mappedStatement.getId().matches(pageSqlId)) {  
         BoundSql boundSql = (BoundSql) metaStatementHandler.getValue("delegate.boundSql");  
         Object parameterObject = boundSql.getParameterObject();  
         if (parameterObject == null) {  
             throw new NullPointerException("parameterObject is null!");  
         } else {  
             // 分页参数作为参数对象parameterObject的一个属性  
             PageParameter page = (PageParameter) metaStatementHandler  
                     .getValue("delegate.boundSql.parameterObject.page");  
             String sql = boundSql.getSql();  
             // 重写sql  
             String pageSql = buildPageSql(sql, page);  
             metaStatementHandler.setValue("delegate.boundSql.sql", pageSql);  
             // 采用物理分页后，就不需要mybatis的内存分页了，所以重置下面的两个参数  
             metaStatementHandler.setValue("delegate.rowBounds.offset",   
             RowBounds.NO_ROW_OFFSET);  
             metaStatementHandler.setValue("delegate.rowBounds.limit", RowBounds.NO_ROW_LIMIT);  
             Connection connection = (Connection) invocation.getArgs()[0];  
             // 重设分页参数里的总页数等  
             setPageParameter(sql, connection, mappedStatement, boundSql, page);  
         }  
     }  
     // 将执行权交给下一个拦截器  
     return invocation.proceed();  
}
```

