https://my.oschina.net/xianggao/blog/591482

# 一、JDBC查询

1. 加载JDBC驱动；
2. 建立并获取数据库连接；
3. 创建 JDBC Statements 对象；
4. 设置SQL语句的传入参数；
5. 执行SQL语句并获得查询结果；
6. 对查询结果进行转换处理并将处理结果返回；
7. 释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）；

```java
public static List<Map<String,Object>> queryForList(){  
    Connection connection = null;  
    ResultSet rs = null;  
    PreparedStatement stmt = null;  
    List<Map<String,Object>> resultList = new ArrayList<Map<String,Object>>();  
          
    try {  
        // 加载JDBC驱动  
        Class.forName("oracle.jdbc.driver.OracleDriver").newInstance();  
        String url = "jdbc:oracle:thin:@localhost:1521:ORACLEDB";  
              
        String user = "trainer";   
        String password = "trainer";   
              
        // 获取数据库连接  
        connection = DriverManager.getConnection(url,user,password);   
              
        String sql = "select * from userinfo where user_id = ? ";  
        // 创建Statement对象（每一个Statement为一次数据库执行请求）  
        stmt = connection.prepareStatement(sql);  
              
        // 设置传入参数  
        stmt.setString(1, "zhangsan");  
              
        // 执行SQL语句  
        rs = stmt.executeQuery();  
              
        // 处理查询结果（将查询结果转换成List<Map>格式）  
        ResultSetMetaData rsmd = rs.getMetaData();  
        int num = rsmd.getColumnCount();  
              
        while(rs.next()){  
            Map map = new HashMap();  
            for(int i = 0;i < num;i++){  
                String columnName = rsmd.getColumnName(i+1);  
                map.put(columnName,rs.getString(columnName));  
            }  
            resultList.add(map);  
        }  
              
    } catch (Exception e) {  
        e.printStackTrace();  
    } finally {  
        try {  
            // 关闭结果集  
            if (rs != null) {  
                rs.close();  
                rs = null;  
            }  
            // 关闭执行  
            if (stmt != null) {  
                stmt.close();  
                stmt = null;  
            }  
            if (connection != null) {  
                connection.close();  
                connection = null;  
            }  
        } catch (SQLException e) {  
            e.printStackTrace();  
        }  
    }        
    return resultList;  
}
```

# 二、优化

## 2.1 数据库连接与关闭

数据库连接频繁的开启和关闭本身就造成了`资源的浪费，影响系统的性能`。

**解决问题：**

​	连接池

但是现在`连接池多种多样，可能存在变化`，有可能采用DBCP的连接池，也有可能采用容器本身的JNDI数据库连接池。

**解决问题：**

我们可以`通过DataSource进行隔离解耦`，我们统一从DataSource里面获取数据库连接，`DataSource具体由DBCP实现还是由容器的JNDI实现都可以`，所以我们将DataSource的具体实现通过让用户配置来应对变化。

## 2.2 SQL统一存取

 **问题描述：**

​	我们使用JDBC进行操作数据库时，`SQL语句基本都散落在各个JAVA类中`，这样有三个不足之处：

​	第一，可读性很差，不利于维护以及做性能调优。

​	第二，改动Java代码需要重新编译、打包部署。

​	第三，不利于取出SQL在数据库客户端执行（取出后还得删掉中间的Java代码，编写好的SQL语句写好后还得通过＋号在Java进行拼凑）。

**解决问题：**

​	将SQL语句都统一放在配置文件或者数据库中，`那么这里就涉及一个SQL语句的加载问题`。

## 2.3 传入参数映射和动态SQL

## 2.4 结果映射和结果缓存

## 2.5 解决重复SQL语句问题

**问题描述：**

​		由于我们将所有SQL语句都放到配置文件中，`这个时候会遇到一个SQL重复的问题`，几个功能的SQL语句其实都差不多，有些可能是SELECT后面那段不同、有些可能是WHERE语句不同。有时候表结构改了，那么我们就需要改多个地方，不利于维护。

**解决问题：**

​	当我们的代码程序出现重复代码时怎么办？`将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用`。对于SQL重复的问题，我们也可以采用这种方式，通过将SQL片段模块化，`将重复的SQL片段独立成一个SQL块，然后在各个SQL语句引用重复的SQL块`，这样需要修改时只需要修改一处即可。

# 三、Mybatis整体框架设计

![输入图片说明](D:\myself\springboot-example\文档\typora\images\mybatis06.png)

## 3.1 接口层

和数据的交互

1. 使用传统的MyBatis提供的API；

2. 使用Mapper接口；

   MyBatis 将配置文件中的每一个<mapper> 节点抽象为一个 Mapper 接口，这个接口中`声明的方法和跟<mapper> 节点中的<select|update|delete|insert> 节点项对应`

   使用**jdk动态代理**为mapper接口生成一个代理类

   用户在接口上可以使用注解来配置SQL语句，可以脱离XML配置文件，实现“0配置”

## 3.2 数据处理层

​	**参数映射**

​		java 数据类型和jdbc数据类型之间的转换

​	**动态SQL语句生成**

> MyBatis 通过传入的参数值，使用 Ognl 来动态地构造SQL语句

​	**封装查询结果集成List<E>**

​		MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。

## 3.3 框架支撑层

## 3.4 引导层

引导层是配置和启动MyBatis配置信息的方式。MyBatis 提供两种方式来引导MyBatis ：`基于XML配置文件的方式和基于Java API 的方式`。

## 3.5 主要构件及其相互关系

- **SqlSession** 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能
- **Executor** MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护
- **StatementHandler** 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。
- **ParameterHandler** 负责对用户传递的参数转换成JDBC Statement 所需要的参数，
- **ResultSetHandler** 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；
- **TypeHandler** 负责java数据类型和jdbc数据类型之间的映射和转换
- **MappedStatement** MappedStatement维护了一条<select|update|delete|insert>节点的封装，
- **SqlSource** 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回
- **BoundSql** 表示动态生成的SQL语句以及相应的参数信息
- **Configuration** MyBatis所有的配置信息都维持在Configuration对象之中。

![输入图片说明](D:\myself\springboot-example\文档\typora\images\mybatis07.png)

## 3.6 SqlSession 工作过程分析

## 3.7 设计模式

**Builder模式**

​	SqlSessionFactory的创建

​	数据库连接环境Environment对象的创建

**动态代理**

​	mapper接口

**责任链模式**

​	插件拦截器

## 3.8  MyBatis数据源与连接池

![输入图片说明](D:\myself\springboot-example\文档\typora\images\mybatis09.png)

数据源DataSource分为三种：

- ​	**UNPOOLED** 不使用连接池的数据源

- ​	**POOLED** 使用连接池的数据源

- ​	**JNDI** 使用JNDI实现的数据源

![输入图片说明](D:\myself\springboot-example\文档\typora\images\mybatis08.png)

对于JNDI类型的数据源DataSource，则是通过JNDI上下文中取值。

当创建SqlSession对象并需要执行SQL语句时，MyBatis才会去调用dataSource对象来创建java.sql.Connection对象。

`也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候`。































 